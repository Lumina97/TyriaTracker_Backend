import axios, { AxiosHeaders, AxiosError } from 'axios';
import { Logger } from 'tslog';
import Queue from 'promise-queue';
import { z } from 'zod';

// src/base/apiBase.ts

// src/base/apiParams.ts
var ApiLanguage = /* @__PURE__ */ ((ApiLanguage2) => {
  ApiLanguage2["English"] = "en";
  ApiLanguage2["French"] = "fr";
  ApiLanguage2["German"] = "de";
  ApiLanguage2["Spanish"] = "es";
  ApiLanguage2["Chinese"] = "zh";
  return ApiLanguage2;
})(ApiLanguage || {});

// src/base/errors/apiNotFoundError.ts
var ApiNotFoundError = class _ApiNotFoundError extends Error {
  constructor() {
    super("The Api did not return any data with the provided arguments");
    Object.setPrototypeOf(this, _ApiNotFoundError.prototype);
  }
};

// src/base/errors/apiRetryFailedError.ts
var ApiRetryFailedError = class _ApiRetryFailedError extends Error {
  constructor() {
    super("The Api failed to return data after several attempts");
    Object.setPrototypeOf(this, _ApiRetryFailedError.prototype);
  }
};

// src/base/errors/apiTokenError.ts
var ApiTokenError = class _ApiTokenError extends Error {
  constructor() {
    super("Api token was required, but was either missing or incorrect");
    Object.setPrototypeOf(this, _ApiTokenError.prototype);
  }
};

// src/base/errors/apiGenericError.ts
var ApiGenericError = class _ApiGenericError extends Error {
  constructor() {
    super("The Api request failed with an unknown error");
    Object.setPrototypeOf(this, _ApiGenericError.prototype);
  }
};

// src/base/errors/apiPermissionsError.ts
var ApiPermissionsError = class _ApiPermissionsError extends Error {
  constructor(scope) {
    super(`The Api token does not have sufficient permissions for this request. ${scope}`);
    Object.setPrototypeOf(this, _ApiPermissionsError.prototype);
  }
};

// src/base/errors/apiTimeoutError.ts
var ApiTimeoutError = class _ApiTimeoutError extends Error {
  constructor() {
    super("The Api request timed out");
    Object.setPrototypeOf(this, _ApiTimeoutError.prototype);
  }
};
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["error"] = 5] = "error";
  LogLevel2[LogLevel2["warn"] = 4] = "warn";
  LogLevel2[LogLevel2["info"] = 3] = "info";
  LogLevel2[LogLevel2["debug"] = 2] = "debug";
  return LogLevel2;
})(LogLevel || {});
var logger = new Logger({
  minLevel: 3 /* info */,
  hideLogPositionForProduction: true
});
var setLogLevel = (minLevel) => {
  logger.settings.minLevel = minLevel;
};
var setPathLogging = (displayFilePath) => {
  logger.settings.hideLogPositionForProduction = !displayFilePath;
};
var queue = new Queue(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
async function sendRequest(options) {
  return await new Promise((resolve, reject) => {
    axios.get(options.url, { ...options }).then(resolve).catch(reject);
  });
}
async function enqueueRequest(options) {
  return await queue.add(async () => await sendRequest(options));
}

// src/base/apiBase.ts
var ApiBase = class {
  _baseUrl = "https://api.guildwars2.com";
  _apiToken;
  _language;
  _rateLimitRetry;
  _rateLimitRetryAttempts;
  constructor(apiParams) {
    this._apiToken = apiParams?.token;
    this._language = apiParams?.language ?? "en" /* English */;
    this._rateLimitRetry = apiParams?.rateLimitRetry ?? true;
  }
  /**
   * Parameters for the api response, at top level
   */
  getParams() {
    return {
      token: this._apiToken,
      language: this._language,
      rateLimitRetry: this._rateLimitRetry
    };
  }
  /**
   * Generic request builder. Adds a finalized request to the concurrency queue
   *
   * @param endpoint - API Endpoint
   * @param apiParams - Query string
   * @param responseType - Type of the response
   * @param attempts - Previously failed retry count
   */
  async buildRequest(endpoint, apiParams, responseType, attempts) {
    const { tokenRequired } = endpoint;
    const url = this._getApiUrl(endpoint, apiParams);
    const headers = new AxiosHeaders();
    headers["Accept-Language"] = this._language;
    if (tokenRequired) {
      if (!this._apiToken) throw new ApiTokenError();
      headers.Authorization = `Bearer ${this._apiToken}`;
    }
    const options = {
      url,
      method: "GET",
      headers
    };
    try {
      logger.info(`Requesting ${options.url}`);
      const response = await enqueueRequest(options);
      const { data } = response;
      const parse = responseType.safeParse(data);
      if (!parse.success) {
        logger.warn(
          "The requested data failed to parse, when using the known schema. Data is still returned, but may be incorrectly typed. Please submit the following log to the developers:"
        );
        logger.warn(parse.error.errors);
      }
      logger.info(`[200] Successful request to ${options.url}`);
      return data;
    } catch (error) {
      return await this.retryRequest(endpoint, options, responseType, apiParams, attempts ?? 0, error);
    }
  }
  /**
   * Retries failed requests
   *
   * @param endpoint - Endpoint to which a request was originally made
   * @param prevOptions - Axios request options
   * @param responseType - Originally requested schema
   * @param apiParams - Query string
   * @param rateLimitAttempt - Current rate-limit retry counter
   * @param prevError - Error that caused a retry
   */
  async retryRequest(endpoint, prevOptions, responseType, apiParams, rateLimitAttempt, prevError) {
    if (prevError instanceof AxiosError && prevError.response) {
      const { status } = prevError.response;
      switch (true) {
        case status === 401: {
          logger.warn(
            // biome-ignore lint/style/noNonNullAssertion: <This will always be present>
            `[401] Failed request to ${prevOptions.url}. Failed to authorize with the provided token.`
          );
          throw new ApiTokenError();
        }
        case status === 403: {
          const requiredScope = prevError.response.data.text.slice(0, 1).toUpperCase() + prevError.response.data.text.slice(1);
          logger.warn(`[403] Failed request to ${prevOptions.url}. ${requiredScope}.`);
          throw new ApiPermissionsError(requiredScope);
        }
        case status === 404: {
          logger.warn(`[404] Failed request to ${prevOptions.url}. No data was returned.`);
          throw new ApiNotFoundError();
        }
        case status === 429: {
          if (!this._rateLimitRetry) {
            logger.warn("[429] Rate-limit has been reached, but retries were turned off. Stopping here.");
            throw new ApiRetryFailedError();
          }
          if (rateLimitAttempt < 3) {
            logger.warn(
              // biome-ignore lint/style/noNonNullAssertion: <This will always be present>
              `[429] Rate-limit has been reached. Request to ${prevOptions.url} will be repeated in 30 seconds.`
            );
            await new Promise((resolve) => setTimeout(() => resolve(), 3e4));
            return await this.buildRequest(endpoint, apiParams, responseType, ++rateLimitAttempt);
          }
          logger.error(`[429] Rate-limit retries failed. Aborting request to ${prevOptions.url}`);
          throw new ApiRetryFailedError();
        }
        case status === 504: {
          logger.warn(`[504] Request to ${prevOptions.url} timed out.`);
          throw new ApiTimeoutError();
        }
        default:
          logger.warn(`[???] Request to ${prevOptions.url} failed. ${prevError.message}`);
          throw new ApiGenericError();
      }
    }
    throw new ApiGenericError();
  }
  /**
   * Builds final Api url from the endpoint and provided parameters
   *
   * @param endpoint - Api endpoint
   * @param urlParams - Parameters
   */
  _getApiUrl(endpoint, urlParams) {
    const { path } = endpoint;
    const regex = /\$\(([^)]+)?\)/g;
    let fullUrl = `${this._baseUrl}/${path}`;
    let match;
    while (match = regex.exec(fullUrl)) {
      const [key, param] = match;
      if (!param) continue;
      const value = encodeURI(String(urlParams[param]));
      fullUrl = fullUrl.replace(key, value);
      regex.lastIndex = 0;
    }
    return fullUrl;
  }
};
var AccountDTO = z.object({
  /** Account id. */
  id: z.string(),
  /** Account age. */
  age: z.number(),
  /** Account name. */
  name: z.string(),
  /** Current account world. */
  world: z.number(),
  /** Account memberships. */
  guilds: z.array(z.string()),
  /** Account leaderships. */
  guild_leader: z.array(z.string()),
  /** Account creation date. */
  created: z.string(),
  /** Account expansion access status. */
  access: z.array(z.string()),
  /** Account commander tag. */
  commander: z.boolean(),
  /** Account fractal level. */
  fractal_level: z.number(),
  /** Account daily achievement points. */
  daily_ap: z.number(),
  /** Account monthly achievement points. */
  monthly_ap: z.number(),
  /** Account World vs World rank. */
  wvw_rank: z.number(),
  /** Last modification date. */
  last_modified: z.string().optional(),
  /** Account build storage slots. */
  build_storage_slots: z.number().optional()
});
var AccountAchievementsDTO = z.array(
  z.object({
    /** Achievement id. */
    id: z.number(),
    /** Achievement bits. */
    bits: z.array(z.number()).optional(),
    /** Current achievement point count. */
    current: z.number(),
    /** Maximum achievement point count. */
    max: z.number().optional(),
    /** Achievement completion status. */
    done: z.boolean(),
    /** Achievement repeatability. */
    repeated: z.number().optional(),
    /** Achievement unlock status. */
    unlocked: z.boolean().optional()
  })
);
var ItemAttributesGeneric = z.object({
  /** Agony Resistance. */
  AgonyResistance: z.number().optional(),
  /** Boon Duration. */
  BoonDuration: z.number().optional(),
  /** Condition Damage. */
  ConditionDamage: z.number().optional(),
  /** Condition Duration. */
  ConditionDuration: z.number().optional(),
  /** Critical Damage. */
  CritDamage: z.number().optional(),
  /** Healing Power. */
  Healing: z.number().optional(),
  /** Power. */
  Power: z.number().optional(),
  /** Precision. */
  Precision: z.number().optional(),
  /** Toughness. */
  Toughness: z.number().optional(),
  /** Vitality. */
  Vitality: z.number().optional()
});
var AccountBankDTO = z.array(
  z.union([
    z.object({
      /** The item's ID. */
      id: z.number(),
      /** The amount of items in the item stack. */
      count: z.number(),
      /** The amount of charges remaining on the item. */
      charges: z.number().optional(),
      /** The skin applied to the item, if it is different from its original. Can be resolved against /v2/skins. */
      skin: z.number().optional(),
      /** The IDs of the dyes applied to the item. Can be resolved against /v2/colors. */
      dyes: z.array(z.number()).optional(),
      /** The item IDs of the runes or sigils applied to the item. */
      upgrades: z.array(z.number()).optional(),
      /** The slot occupied by the upgrade at the corresponding position in upgrades. */
      upgrade_slot_indices: z.array(z.number()).optional(),
      /** An array of item IDs for each infusion applied to the item. */
      infusions: z.array(z.number()).optional(),
      /** The stats of the item. */
      stats: z.object({
        /** The ID of the item's stats. Can be resolved against /v2/itemstats. */
        id: z.number(),
        /** The list of stats provided by this item. Can be empty object. */
        attributes: ItemAttributesGeneric
      }).optional()
    }).and(
      z.discriminatedUnion("binding", [
        z.object({
          /** The current binding of the item. Bound to the character */
          binding: z.literal("Character"),
          /** Which character it is bound to. */
          bound_to: z.string()
        }),
        z.object({
          /** The current binding of the item. Bound to the account.  */
          binding: z.literal("Account"),
          /** This will never appear. */
          bound_to: z.undefined()
        }),
        z.object({
          /** If the item has no binding, this will never appear. */
          binding: z.undefined(),
          /** This will never appear. */
          bound_to: z.undefined()
        })
      ])
    ),
    /** Bank slots can be null. */
    z.null()
  ])
);
var AccountBuildStorageDTO = z.array(
  z.object({
    /** Name of the stored build. */
    name: z.string(),
    /** Profession of the stored build. */
    profession: z.string(),
    /** Specializations of the stored build. */
    specializations: z.array(
      z.object({
        /** Id of the specialization. */
        id: z.number(),
        /** Selected traits. */
        traits: z.array(z.union([z.number(), z.null()]))
      })
    ),
    /** Selected utility skills. */
    skills: z.object({
      /** Id of the heal skill. */
      heal: z.union([z.number(), z.null()]),
      /** Ids of the utility skills. */
      utilities: z.array(z.union([z.number(), z.null()])),
      /** Id of the elite skill. */
      elite: z.union([z.number(), z.null()])
    }).optional(),
    /** Selected aquatic utility skills. */
    aquatic_skills: z.object({
      /** Id of the heal skill. */
      heal: z.union([z.number(), z.null()]),
      /** Ids of the utility skills. */
      utilities: z.array(z.union([z.number(), z.null()])),
      /** Id of the elite skill. */
      elite: z.union([z.number(), z.null()])
    }).optional(),
    /** Selected legends (revenant only). */
    legends: z.array(z.union([z.string(), z.null()])).optional(),
    /** Selected aquatic legends (revenant only). */
    aquatic_legends: z.array(z.union([z.string(), z.null()])).optional()
  })
);
var AccountDailyCraftingDTO = z.array(
  /** Id of the crafted daily item. */
  z.string()
);
var AccountDungeonsDTO = z.array(
  /** Id of the completed dungeon. */
  z.string()
);
var AccountDyesDTO = z.array(
  /** Id of the dye. */
  z.number()
);
var AccountEmotesDTO = z.array(
  /**
   * Id of the emote.
   */
  z.string()
);
var AccountFinishersDTO = z.array(
  z.object({
    /** Id of the finisher. */
    id: z.number(),
    /** Indicated whether the finisher is permanent or temporary. */
    permanent: z.boolean(),
    /** Indicates uses if the finisher is temporary. */
    quantity: z.number().optional()
  })
);
var AccountGlidersDTO = z.array(
  /** Id of the glider. */
  z.number()
);
var AccountHomeNodesDTO = z.array(
  /** Ids of node unlocked in home instance. */
  z.string()
);
var AccountHomeCatsDTO = z.array(
  /** Ids of cat unlocked in home instance. */
  z.number()
);
var AccountHomesteadDecorationsDTO = z.array(
  z.object({
    /** Deocration id. */
    id: z.number(),
    /** Decoration count. */
    count: z.number()
  })
);
var stringArrayType = z.array(z.string());
var numberArrayType = z.array(z.number());

// src/models/account/account.homestead.glyphs.dto.ts
var AccountHomesteadGlyphsDTO = stringArrayType;
var AccountInventoryDTO = z.array(
  z.union([
    z.null(),
    z.object({
      /** Item id. */
      id: z.number(),
      /** The amount of items in the stack. */
      count: z.number(),
      /** The amount of charges remaining. */
      charges: z.number().optional(),
      /** The skin applied to the item. */
      skin: z.number().optional(),
      /** Item ids for runes and signets applied to the item. */
      upgrades: z.array(z.number()).optional(),
      /** Item ids for infusions applied to the item. */
      infusions: z.array(z.number()).optional(),
      /** Item binding. "Account" if available at all. */
      binding: z.literal("Account").optional()
    })
  ])
);
var AccountJadebotsDTO = z.array(
  /** The jadebot id. Can be resolved against /v2/jadebots.  */
  z.number()
);
var AccountLegendaryArmoryDTO = z.array(
  z.object({
    /** The id of the armory items. Can be resolved against /v2/items and /v2/legendaryarmory. */
    id: z.number(),
    /** The count of that item available for use in a single equipment template. */
    count: z.number()
  })
);
var AccountLuckDTO = z.array(
  z.object({
    /** Always the string "luck". */
    id: z.literal("luck"),
    /** The amount of luck consume. */
    value: z.number()
  })
);
var AccountMailCarriersDTO = z.array(
  /** Id of the mail carrier. */
  z.number()
);
var AccountMapChestsDTO = z.array(
  /** Id of the acquired daily hero choice chest. */
  z.string()
);
var AccountMasteriesDTO = z.array(
  z.object({
    /** The id of the mastery resolvable against /v2/masteries. */
    id: z.number(),
    /**
     * Indicates the level at which the mastery is on the account.
     * Is a 0-indexed reference to the /v2/masteries.
     */
    level: z.number()
  })
);
var AccountMasteryPointsDTO = z.object({
  /** Mastery points redeemed per section. */
  totals: z.array(
    z.object({
      /** Name of the region for the masteries. */
      region: z.string(),
      /** Amount of masteries of this region spent in mastery tracks. */
      spent: z.number(),
      /** Amount of masteries of this region earned for the account. */
      earned: z.number()
    })
  ),
  /** Array of unlocked mastery ids. */
  unlocked: z.array(z.number())
});
var AccountMaterialsDTO = z.array(
  z.object({
    /** Item id of the material. */
    id: z.number(),
    /** Material category. Can be resolved against /v2/materials. */
    category: z.number(),
    /** Binding of the material. Either "Account" or undefined. */
    binding: z.literal("Account").optional(),
    /** Material count in the account storage. */
    count: z.number()
  })
);
var AccountMinisDTO = z.array(
  /** Id of the mini. */
  z.number()
);
var AccountMountSkinsDTO = z.array(
  /** Id of the skin. */
  z.number()
);
var AccountMountTypesDTO = z.array(
  /** Type of the mount. */
  z.string()
);
var AccountNoveltiesDTO = z.array(
  /** Id of the novelty. */
  z.number()
);
var AccountOutfitsDTO = z.array(
  /** Id of the outfit. */
  z.number()
);
var AccountProgressionDTO = z.array(
  z.object({
    /** Progression name. */
    id: z.string(),
    /** Progression value. */
    value: z.number()
  })
);
var AccountPvpHeroesDTO = z.array(
  /** Id of the hero.*/
  z.number()
);
var AccountRaidsDTO = z.array(
  /** Id of the raid. */
  z.string()
);
var AccountRecipesDTO = z.array(
  /** Id of the recipe. */
  z.number()
);
var AccountSkiffsDTO = z.array(
  /** The id of the skiff skin. Can be resolved against /v2/skiffs. */
  z.number()
);
var AccountSkinsDTO = z.array(
  /** Id of the skin. */
  z.number()
);
var AccountTitlesDTO = z.array(
  /** Id of the title. */
  z.number()
);
var AccountWalletDTO = z.array(
  z.object({
    /** Id of the currency. Can be resolved against /v2/currencies. */
    id: z.number(),
    /** The amount of this currency. */
    value: z.number()
  })
);
var AccountWizardsVaultDailyDTO = z.object({
  /** The current progress to the meta achievement for the daily. */
  meta_progress_current: z.number(),
  /** The threshold for the meta progress to be 'complete', and the meta reward claimable. */
  meta_progress_complete: z.number(),
  /** The ID of the item you receive for claiming the meta reward */
  meta_reward_item_id: z.number(),
  /** The amount of Astral Acclaim you receive for claiming the meta reward */
  meta_reward_astral: z.number(),
  /** Whether the account has claimed the meta reward. */
  meta_reward_claimed: z.boolean(),
  /** An array of objects detailing each daily objective */
  objectives: z.array(
    z.object({
      /** The ID of the objective. */
      id: z.number(),
      /** The title of the objective. */
      title: z.string(),
      /** The reward track containing the objective. */
      track: z.string(),
      /** The astral acclaim awarded for the objective. */
      acclaim: z.number(),
      /** The current progress of the objective. */
      progress_current: z.number(),
      /** The progress status of the objective. */
      progress_complete: z.number(),
      /** The claim status of the objective. */
      claimed: z.boolean()
    })
  )
});
var AccountWizardsVaultListingsDTO = z.array(
  z.object({
    /** The listing id. */
    id: z.number(),
    /** The id of the item */
    item_id: z.number(),
    /** The quantity of the item the user receives */
    item_count: z.number(),
    /** Appears to be the position in the wizards vault UI. */
    type: z.enum(["Featured", "Normal", "Legacy"]),
    /** The quantity of Astral Acclaim to purchase . */
    cost: z.number(),
    /** Amount of the item already purchased. Not included if the reward is unlimited. */
    purchased: z.number().optional(),
    /** Maximum amount that can be purchased. Not included if the reward is unlimited. */
    purchase_limit: z.number().optional()
  })
);
var AccountWizardsVaultSpecialDTO = z.object({
  /** An array of objects detailing each weekly objective */
  objectives: z.array(
    z.object({
      /** The ID of the objective. */
      id: z.number(),
      /** The title of the objective. */
      title: z.string(),
      /** The reward track containing the objective. */
      track: z.string(),
      /** The astral acclaim awarded for the objective. */
      acclaim: z.number(),
      /** The current progress of the objective. */
      progress_current: z.number(),
      /** The progress status of the objective. */
      progress_complete: z.number(),
      /** The claim status of the objective. */
      claimed: z.boolean()
    })
  )
});
var AccountWizardsVaultWeeklyDTO = z.object({
  /** The current progress to the meta achievement for the weekly. */
  meta_progress_current: z.number(),
  /** The threshold for the meta progress to be 'complete', and the meta reward claimable. */
  meta_progress_complete: z.number(),
  /** The ID of the item you receive for claiming the meta reward */
  meta_reward_item_id: z.number(),
  /** The amount of Astral Acclaim you receive for claiming the meta reward */
  meta_reward_astral: z.number(),
  /** Whether the account has claimed the meta reward. */
  meta_reward_claimed: z.boolean(),
  /** An array of objects detailing each weekly objective */
  objectives: z.array(
    z.object({
      /** The ID of the objective. */
      id: z.number(),
      /** The title of the objective. */
      title: z.string(),
      /** The reward track containing the objective. */
      track: z.string(),
      /** The astral acclaim awarded for the objective. */
      acclaim: z.number(),
      /** The current progress of the objective. */
      progress_current: z.number(),
      /** The progress status of the objective. */
      progress_complete: z.number(),
      /** The claim status of the objective. */
      claimed: z.boolean()
    })
  )
});
var AccountWorldBossesDTO = z.array(
  /** Name of the world boss. */
  z.string()
);
var AchievementCategoriesDTO = z.array(
  z.object({
    /** Category id.. */
    id: z.number(),
    /** Category name.. */
    name: z.string(),
    /** Category description. */
    description: z.string(),
    /** A number describing where to sort this category among other the other
     * categories in its group. Lowest numbers go first, highest numbers go last. */
    order: z.number(),
    /** A URL to an image for the icon of the category. */
    icon: z.string(),
    /** Achievement ids in this category.
     * Can be resolved against /v2/achievements. */
    achievements: z.array(z.number())
  })
);
var AchievementGroupsDTO = z.object({
  /** The group's GUID. */
  id: z.string(),
  /** The group's name. */
  name: z.string(),
  /** The group's description. */
  description: z.string(),
  /**
   * A number describing where to sort this group among other groups.
   * Lowest numbers go first, highest numbers go last. */
  order: z.number(),
  /**
   * An array containing a number of category IDs that this group contains.
   * Can be resolved against /v2/achievements/categories. */
  categories: z.array(z.number())
});
var BackstoryAnswersDTO = z.array(
  z.object({
    /** The id of the answer. */
    id: z.string(),
    /** The title (or name) of the answer. */
    title: z.string(),
    /** The description of the answer; as displayed in-game when presented as an answer choice
     * to a question during the Biography portion of character creation. */
    description: z.string(),
    /** The Story Journal entry for the answer; as displayed in-game. */
    journal: z.string(),
    /** The id of the Biography question that this answers; Can be resolved against v2/backstory/questions. */
    question: z.number(),
    /** When present, an array of professions that this answer is available as a choice for. */
    professions: z.array(z.string()).optional(),
    /** When present, an array of races that this answer is available as a choice for. */
    races: z.array(z.string()).optional()
  })
);
var BackstoryQuestionsDTO = z.array(
  z.object({
    /** The id of the question. */
    id: z.number(),
    /** The title (or name) of the question. */
    title: z.string(),
    /** The description of the question; as displayed in-game when presented as a Biography choice during character creation. */
    description: z.string(),
    /** The order in which this question is displayed in-game while answering your characters' Biography questions during character creation. */
    order: z.number(),
    /** The list of answers for this question; Can be resolved against v2/backstory/answers. */
    answers: z.array(z.string()),
    /** When present, an array of races that this question is presented to. */
    races: z.array(z.string()).optional(),
    /** When present, an array of professions that this question is presented to. */
    professions: z.array(z.string()).optional()
  })
);
var CharactersDTO = z.array(
  /** Character name. */
  z.string()
);
var CharacterBackstoryDTO = z.object({
  /** Character backstory selections. Can be resolved against /v2/backstory/answers. */
  backstory: z.array(z.string())
});
var Specialization = z.array(
  z.object({
    /* The specialization id or null if none is selected.
     * Can be resolved against /v2/specializations. */
    id: z.union([z.number(), z.null()]),
    /* Three trait ids or null in places where none is selected.
     * Can be resolved against /v2/traits. */
    traits: z.array(z.union([z.number(), z.null()]))
  })
);
var Skills = z.object({
  /** The id of the heal skill or null if none is selected. */
  heal: z.union([z.number(), z.null()]),
  /** Three utility skill ids or null in places where none is selected. */
  utitilies: z.array(z.union([z.number(), z.null()])).optional(),
  /** The id of the elite skill or null if none is selected. */
  elite: z.union([z.number(), z.null()])
});
var Pets = z.object({
  /** Contains the two pet ids the ranger has equipped for terrestrial combat. */
  terrestrial: z.array(z.number()),
  /** Contains the two pet ids the ranger has equipped for aquatic combat. */
  aquatic: z.array(z.number())
});
var Build = z.object({
  /** Name given to the build */
  name: z.string(),
  /** The characters' profession. Can be resolved against /v2/professions. */
  profession: z.string(),
  /** Three objects providing information about the characters selected specializations. */
  specializations: Specialization,
  /* Contains information about the characters selected skills.
   * Can be resolved against /v2/skills. */
  skills: Skills,
  /* Contains information about the characters selected underwater skills.
   * Can be resolved against /v2/skills. */
  aquatic_skills: Skills,
  /* Included for revenants only. Two legend ids or null in places where none is selected.
   * Can be resolved against /v2/legends. */
  legends: z.array(z.union([z.string(), z.null()])).length(2).optional(),
  /** Included for revenants only. The structure is the same as the one of legends above. */
  aquatic_legends: z.array(z.union([z.string(), z.null()])).length(2).optional(),
  /**
   * Included for rangers only. Containers information about the characters selected pets.
   * Can be resolved against /v2/pets.
   */
  pets: Pets.optional()
});
var CharacterBuildTabsDTO = z.array(
  z.object({
    /** Tab position. */
    tab: z.number(),
    /** Whether this is the tab selected on the character currently. */
    is_active: z.boolean(),
    /** Detailed information about the build. */
    build: Build
  })
);
var CharacterCoreDTO = z.object({
  /** Character name. */
  name: z.string(),
  /** Character race. */
  race: z.enum(["Asura", "Charr", "Human", "Norn", "Sylvari"]),
  /** Character gender. */
  gender: z.enum(["Male", "Female"]),
  /** Character profession. */
  profession: z.enum([
    "Elementalist",
    "Engineer",
    "Guardian",
    "Mesmer",
    "Necromancer",
    "Ranger",
    "Revenant",
    "Thief",
    "Warrior"
  ]),
  /** Character level. */
  level: z.number(),
  /** Character guild. */
  guild: z.union([z.string(), z.null()]),
  /** Character age. */
  age: z.number(),
  /** Character creation date. */
  created: z.string(),
  /** Character deaths. */
  deaths: z.number(),
  /** Character title id. */
  title: z.number().optional()
});
var CharacterCraftingDTO = z.object({
  /**
   * Crafting disciplines of a character
   */
  crafting: z.array(
    z.object({
      /** An array containing an entry for each crafting discipline the character has unlocked. */
      discipline: z.enum([
        "Armorsmith",
        "Artificer",
        "Chef",
        "Huntsman",
        "Jeweler",
        "Leatherworker",
        "Scribe",
        "Tailor",
        "Weaponsmith"
      ]),
      /** The name of the discipline. */
      rating: z.number(),
      /** Describes if the given discipline is currently active or not on the character. */
      active: z.boolean()
    })
  )
});
var EquipmentStatsGeneric = z.object({
  /** Item stat id. Can be resolved against /v2/itemstats. */
  id: z.number(),
  /** Summary of the stats on the item. Only available if the item has selectable stats. */
  attributes: z.object({
    /** Power. */
    Power: z.number().optional(),
    /** Precision. */
    Precision: z.number().optional(),
    /** Toughness. */
    Toughness: z.number().optional(),
    /** Vitality. */
    Vitality: z.number().optional(),
    /** Condition Damage. */
    ConditionDamage: z.number().optional(),
    /** Condition Duration. */
    ConditionDuration: z.number().optional(),
    /** Healing Power. */
    Healing: z.number().optional(),
    /** Boon Duration. */
    BoonDuration: z.number().optional()
  })
});
var EquipmentGeneric = z.object({
  /** Item id. Can be resolved against /v2/items. */
  id: z.number(),
  /** Equipment slot, in which the item is slotted. */
  slot: z.enum([
    "HelmAquatic",
    "Backpack",
    "Coat",
    "Boots",
    "Gloves",
    "Helm",
    "Leggings",
    "Shoulders",
    "Accessory1",
    "Accessory2",
    "Ring1",
    "Ring2",
    "Amulet",
    "Relic",
    "WeaponAquaticA",
    "WeaponAquaticB",
    "WeaponA1",
    "WeaponA2",
    "WeaponB1",
    "WeaponB2",
    "Sickle",
    "Axe",
    "Pick",
    "PowerCore",
    "FishingLure",
    "FishingBait",
    "FishingRod",
    "SensoryArray"
  ]).optional(),
  /** Infusions Ids. Can be resolved against /v2/items. */
  infusions: z.array(z.number()).optional(),
  /** Upgrade Ids. Can be resolved against /v2/items. */
  upgrades: z.array(z.number()).optional(),
  /** Skin id. Can be resolved against /v2/skins. */
  skin: z.number().optional(),
  /** Equipment stats, if the item offers a selection of prefixes. */
  stats: EquipmentStatsGeneric.optional(),
  /** Where item is stored. */
  location: z.enum(["Equipped", "Armory", "EquippedFromLegendaryArmory", "LegendaryArmory"]).optional(),
  /** Tabs where this item is used in. */
  tabs: z.array(z.number()).optional(),
  /** Amount of charges remaining. */
  charges: z.number().optional(),
  /** Dyes selected for the equipment piece. Defaults to null. Can be resolved against /v2/colors. */
  dyes: z.array(z.union([z.number(), z.null()])).optional()
}).and(
  z.discriminatedUnion("binding", [
    z.object({
      /** Equipment binding. */
      binding: z.literal("Character"),
      /** Name of the character to which the item is bound. */
      bound_to: z.string()
    }),
    z.object({
      /** Equipment binding. */
      binding: z.literal("Account"),
      /** Undefined, when binding is "Account" */
      bound_to: z.undefined()
    }),
    z.object({
      /** Not bound. */
      binding: z.undefined(),
      /** Undefined, since not bound. */
      bound_to: z.undefined()
    })
  ])
);
var CharacterEquipmentDTO = z.object({
  /** Character equipment. */
  equipment: z.array(EquipmentGeneric)
});
var CharacterEquipmentTabDTO = z.object({
  /** Equipment tab id. */
  tab: z.number(),
  /** Equipment tab name. */
  name: z.string(),
  /** Whether the equipment tab is active. */
  is_active: z.boolean(),
  /** Array of equipment objects in the equipment tab. */
  equipment: z.array(EquipmentGeneric),
  /** PvP equipment in the equipment tab */
  equipment_pvp: z.object({
    /** Amulet id. Can be resolved against /v2/pvp/amulets. */
    amulet: z.union([z.number(), z.null()]),
    /** Rune id. Can be resolved against /v2/items. */
    rune: z.union([z.number(), z.null()]),
    /**
     * Sigil ids. Can be resolved against /v2/items.
     * Provided in the following order:
     * - Primary Weapon
     * - Primary Off-hand Weapon
     * - Secondary Weapon
     * - Secondary Off-hand Weapon
     */
    sigils: z.array(z.union([z.number(), z.null()]))
  })
});
var CharacterEquipmentTabsDTO = z.array(CharacterEquipmentTabDTO);
var CharacterHeroPointsDTO = z.array(
  /** Hero point id. Can be resolved against "skill_challenges" /v2/continents. */
  z.string()
);
var BagInventory = z.object({
  /** Item id. Can be resolved against /v2/items */
  id: z.number(),
  /** Amount of the item in the stack. */
  count: z.number(),
  /** Number of charges of the item */
  charges: z.number().optional(),
  /** Infusion ids. Can be resolved against /v2/items. */
  infusions: z.array(z.number()).optional(),
  /** Upgrade ids. Can be resolved against /v2/items. */
  upgrades: z.array(z.number()).optional(),
  /** Indices of the slots where upgrades are installed. */
  upgrade_slot_indices: z.array(z.number()).optional(),
  /** Skin id. Can be resolved against /v2/skins. */
  skin: z.number().optional(),
  /** Stat information of an item, if it has selectable prefixes. */
  stats: EquipmentStatsGeneric.optional(),
  /** Dye ids. Null if not assigned. Can be resolved against /v2/colors */
  dyes: z.array(z.union([z.null(), z.number()])).optional()
}).and(
  z.discriminatedUnion("binding", [
    z.object({
      /** Equipment binding. */
      binding: z.literal("Character"),
      /** Name of the character to which the item is bound. */
      bound_to: z.string()
    }),
    z.object({
      /** Equipment binding. */
      binding: z.literal("Account"),
      /** Undefined, when binding is "Account" */
      bound_to: z.undefined()
    }),
    z.object({
      /** Not bound. */
      binding: z.undefined(),
      /** Undefined, since not bound. */
      bound_to: z.undefined()
    })
  ])
);
var CharacterInventoryDTO = z.object({
  /** Array of bags in the character's inventory. */
  bags: z.array(
    z.union([
      z.object({
        /** Bag id. Can be resolved against /v2/items. */
        id: z.number(),
        /** Number of bag slots in this bag. */
        size: z.number(),
        /** Bag contents structure, or null of there are no items in the bag. */
        inventory: z.array(z.union([z.null(), BagInventory]))
      }),
      /** The bag is missing, but the slot is unlocked */
      z.null()
    ])
  )
});
var CharacterQuestsDTO = z.array(
  /** Id of the quest, selected during story progression. */
  z.number()
);
var CharacterRecipesDTO = z.object({
  /** Array of recipe ids. Can be resolved against /v2/recipes. */
  recipes: z.array(z.number())
});
var CharacterSuperAdventureBoxDTO = z.object({
  /** Super Adventure Box zones. */
  zones: z.array(
    z.object({
      /** Unique zone id. */
      id: z.number(),
      /** Mode used when completing this zone. */
      mode: z.enum(["infantile", "normal", "tribulation"]),
      /** Which world the zone is in. */
      world: z.number(),
      /** Zone number. */
      zone: z.number()
    })
  ),
  /** Super Adventure Box unlocks. */
  unlocks: z.array(
    z.object({
      /** Unique unlock id. */
      id: z.number(),
      /** Unlocalized unlock description. */
      name: z.string().optional()
    })
  ),
  /** Super Adventure box songs. */
  songs: z.array(
    z.object({
      /** Unique song id. */
      id: z.number(),
      /** Unlocalized song description. */
      name: z.enum(["secret_song", "gatekeeper_lullaby", "shatter_serenade"])
    })
  )
});
var Skill = z.object({
  /** Id of the heal skill. Can be resolved against /v2/skills. */
  heal: z.union([z.null(), z.number()]),
  /** Ids of the utilities, or null if it's not set. Can be resolved against /v2/skills */
  utilities: z.array(z.union([z.null(), z.number()])),
  /** Id of the elite skill. Can be resolved against /v2/skills. */
  elite: z.union([z.null(), z.number()]),
  /** Ids of the legends. Revenant only. Can be resolved against /v2/legends. */
  legends: z.array(z.union([z.null(), z.string()])).optional()
});
var CharacterSkillsDTO = z.object({
  /** PvE, PvP, and WvW skill layout of a character. */
  skills: z.object({
    /** PvE skills. */
    pve: Skill,
    /** PvP skills. */
    pvp: Skill,
    /** WvW skills. */
    wvw: Skill
  })
});
var Specialization2 = z.object({
  /** Specialization id. Can be resolved against /v2/specializations. */
  id: z.number(),
  /** Trait ids. Can be resolved against /v2/traits. */
  traits: z.array(z.number())
});
var CharacterSpecializationsDTO = z.object({
  /** Contains PvE, PvP, and WvW specialization objects currently equipped. */
  specializations: z.object({
    /** PvE specializations currently equipped. */
    pve: z.array(Specialization2),
    /** PvP specializations currently equipped. */
    pvp: z.array(Specialization2),
    /** WvW specializations currently equipped. */
    wvw: z.array(Specialization2)
  })
});
var CharacterTrainingDTO = z.object({
  /** Skill trained in each skill tree. */
  training: z.array(
    z.object({
      /** Skill tree id. Can be resolved against /v2/profession, in training section. */
      id: z.number(),
      /** How many points have been spent in this tree. */
      spent: z.number(),
      /** Whether the tree is fully trained. */
      done: z.boolean()
    })
  )
});
var CommerceDeliveryDTO = z.object({
  /** Amount of coins ready for pickup */
  coins: z.number(),
  /** Items ready for pickup */
  items: z.array(
    z.object({
      /** The item id. Can be resolved against /v2/items. */
      id: z.number(),
      /** Item count. */
      count: z.number()
    })
  )
});
var CommerceExchangeDTO = z.object({
  /** The number of coins you required for a single currency unit. */
  coins_per_gem: z.number(),
  /** The number of gems you get for the specified quantity of currency. */
  quantity: z.number()
});
var CommerceListingsDTO = z.array(
  z.object({
    /** The item id. Can be resolved against /v2/items. */
    id: z.number(),
    /** List of all buy listings, descending from the highest buy order. */
    buys: z.array(
      z.object({
        /** The number of individual listings this object refers to. */
        listings: z.number(),
        /** The sell offer or buy order price in coins. */
        unit_price: z.number(),
        /** The amount of items being sold/bought in this listing. */
        quantity: z.number()
      })
    ),
    /** List of all sell listings, ascending from the lowest sell order. */
    sells: z.array(
      z.object({
        /** The number of individual listings this object refers to. */
        listings: z.number(),
        /** The sell offer or buy order price in coins. */
        unit_price: z.number(),
        /** The amount of items being sold/bought in this listing. */
        quantity: z.number()
      })
    )
  })
);
var CommercePricesDTO = z.array(
  z.object({
    /** The item id. Can be resolved against /v2/items. */
    id: z.number(),
    /** Whether free to play accounts can purchase or sell this item. */
    whitelisted: z.boolean(),
    /** Buy information. */
    buys: z.object({
      /** The highest buy order or lowest sell offer price in copper coins. */
      quantity: z.number(),
      /** The amount of items being sold/bought. */
      unit_price: z.number()
    }),
    /** Sell information. */
    sells: z.object({
      /** The highest buy order or lowest sell offer price in copper coins. */
      quantity: z.number(),
      /** The amount of items being sold/bought. */
      unit_price: z.number()
    })
  })
);
var CommerceTransactionDTO = z.array(
  z.object({
    /** Id of the transaction. */
    id: z.number(),
    /** The item id. Can be resolved against /v2/items. */
    item_id: z.number(),
    /** The price in coins. */
    price: z.number(),
    /** The quantity of the item. */
    quantity: z.number(),
    /** The date of creation, using ISO-8601 standard. */
    created: z.string(),
    /** The date of purchase, using ISO-8601 standard. Not shown in current second-level endpoint. */
    purchased: z.string().optional()
  })
);
var ContinentsMaps = z.object({
  /** The map name. */
  name: z.string(),
  /** The minimum level of the map. */
  min_level: z.number(),
  /** The maximum level of the map. */
  max_level: z.number(),
  /** The default floor of the map. */
  default_floor: z.number(),
  /** The coordinates of the map label. */
  label_coord: z.array(z.number()).length(2).optional(),
  // TODO: The API is not telling us something correctly
  /** The dimensions of the map, given as the coordinates of the lower-left (SW) and upper-right (NE) corners. */
  map_rect: z.array(z.array(z.number())),
  /**
   * The dimensions of the map within the continent coordinate system,
   * given as top-left (NW) and bottom-right (SE) corner coordinates.
   */
  continent_rect: z.array(z.array(z.number()).length(2)).length(2),
  /** A list of points of interest (landmarks, waypoints, vistas, etc). */
  points_of_interest: z.record(
    z.string(),
    z.object({
      /** The point of interest id. */
      id: z.number(),
      /** The name of the point of interest. */
      name: z.string().optional(),
      // TODO: A lot of POIs seemingly dont have a name
      /** Type of the point of interest. */
      type: z.string(),
      /** The floor of this object. */
      floor: z.number(),
      /** The coordinates of this object. */
      coord: z.array(z.number()),
      /** The point of interest chat link. */
      chat_link: z.string(),
      /** PoI icon. Only available for unlock types */
      icon: z.string().optional()
    })
  ),
  /** A list of renown hearts. */
  tasks: z.record(
    z.string(),
    z.object({
      /** The renown heart id. */
      id: z.number(),
      /** The objective or name of the heart. */
      objective: z.string(),
      /** The level of the heart. */
      level: z.number(),
      /** The coordinates where it takes place. */
      coord: z.array(z.number()),
      /** A list of coordinates marking the boundary of the heart. */
      bounds: z.array(z.array(z.number())),
      /** The renown heart chat link. */
      chat_link: z.string()
    })
  ),
  /** A list of skill challenges. */
  skill_challenges: z.array(
    z.object({
      /**
       * The hero challenge id, formed of two numbers separated by a dash.
       * The first number represents the expansion (0 for Core Tyria, 1 for Heart of Thorns and 2 for Path of Fire),
       * and therefore could be used to change the hero challenge map marker icon.
       * If the first number and dash prefix is removed from the string,
       * the second number is no longer unique among other hero challenges.
       */
      id: z.string().optional(),
      // TODO: This is literally not returned by the api, anywhere
      /** The coordinates of this hero challenge. */
      coord: z.array(z.number())
    })
  ),
  /** A list of areas within the map. */
  sectors: z.record(
    z.string(),
    z.object({
      /** The area id. */
      id: z.number(),
      /** The name of the area. */
      name: z.string().optional(),
      // TODO: Same as POIs, a lot does not have a name?
      /** The level of the area. */
      level: z.number(),
      /** The coordinates of this area (this is usually the center position). */
      coord: z.array(z.number()),
      /** A list of coordinates marking the boundary of the area. */
      bounds: z.array(z.array(z.number())),
      /** The area chat link. */
      chat_link: z.string()
    })
  ),
  /** A list of adventures within the map. */
  adventures: z.array(
    z.object({
      /** The adventure guid (token length 8-4-4-4-12 with a dash between each group of digits). */
      id: z.string(),
      /** The coordinates of the start of the adventure. */
      coord: z.array(z.number()),
      /** The name of the adventure. */
      name: z.string(),
      /** The description of the adventure. */
      description: z.string()
    })
  ),
  /** A list of mastery insights within the map. */
  mastery_points: z.array(
    z.object({
      /** The mastery insight id. */
      id: z.number(),
      /** The region of the mastery insight, which determines its color. */
      region: z.string(),
      /** The coordinates of the mastery insight. */
      coord: z.array(z.number())
    })
  )
});
var ContinentsMapsDTO = z.array(ContinentsMaps);
var ContinentsRegions = z.object({
  /** Id of the region. */
  id: z.number(),
  /** Name of the region. */
  name: z.string(),
  /** The coordinates of the region label. */
  label_coord: z.array(z.number()),
  /** The dimensions of the continent, expressed as top-left (NW) and bottom-right (SE) corner coordinates. */
  continent_rect: z.array(z.array(z.number()).length(2)).length(2),
  /** A mapping from the map id to an object. */
  maps: z.record(z.string(), ContinentsMaps)
});
var ContinentsRegionsDTO = z.array(ContinentsRegions);
var ContinentsFloors = z.object({
  /** Floor id. */
  id: z.number(),
  /** Dimensions of the region texture. */
  texture_dims: z.array(z.number()),
  /**
   * If present, represents a rectangle of textures.
   * Each tile coordinate outside this rectangle is not available on the server.
   */
  clamped_view: z.array(z.array(z.number()).length(2)).length(2).optional(),
  // TODO: Another instance of data missing
  /** Mapping from the region id to an object. */
  regions: z.record(z.string(), ContinentsRegions)
});
var ContinentsFloorsDTO = z.array(ContinentsFloors);
var Continents = z.object({
  /** Continent id. */
  id: z.number(),
  /** Continent name. */
  name: z.string(),
  /** Width and height dimensions of the continent. */
  continents_dims: z.array(z.number()).length(2).optional(),
  /** Minimal zoom level for use with this map tile. */
  min_zoom: z.number(),
  /** Maximum zoom level for use with this map tile. */
  max_zoom: z.number(),
  /** List of floor ids available for this continent. */
  floors: z.array(z.number())
});
var ContinentsDTO = z.array(Continents);
var GuildDTO = z.object({
  /** The unique guild id. */
  id: z.string(),
  /** The guild name. */
  name: z.string(),
  /** The 2 to 4 letter guild tag. */
  tag: z.string(),
  /** The guild emblem. */
  emblem: z.object({
    /** An array containing information of the background of the guild emblem. */
    background: z.object({
      /** The emblem id. */
      id: z.number(),
      /** Array of emblem color ids. */
      colors: z.array(z.number())
    }),
    /** An array containing information of the foreground of the guild emblem. */
    foreground: z.object({
      /** The emblem id. */
      id: z.number(),
      /** Array of emblem color ids. */
      colors: z.array(z.number())
    }),
    /** An array of manipulations applied to the logo. */
    flags: z.array(
      z.enum([
        "FlipBackgroundHorizontal",
        "FlipBackgroundVertical",
        "FlipForegroundHorizontal",
        "FlipForegroundVertical"
      ])
    )
  }),
  /** The current guild level. Only available when the Api token has member or leader privileges. */
  level: z.number().optional(),
  /** The message of the day. Only available when the Api token has member or leader privileges. */
  motd: z.string().optional(),
  /** The current guild influence. Only available when the Api token has member or leader privileges. */
  influence: z.number().optional(),
  /** The current aetherium level. Only available when the Api token has member or leader privileges. */
  aetherium: z.string().optional(),
  /** The current level of guild favor. Only available when the Api token has member or leader privileges. */
  favor: z.number().optional(),
  /** The current member count. Only available when the Api token has member or leader privileges. */
  member_count: z.number().optional(),
  /** The maximum member count. Only available when the Api token has member or leader privileges. */
  member_capacity: z.number().optional()
});
var GuildLogJoinedDTO = z.object({
  /** The type of log entry. */
  type: z.literal("joined"),
  /** The account name of the guild member who generated this log entry. */
  user: z.string()
});
var GuildLogInvitedDTO = z.object({
  /** The type of log entry. */
  type: z.literal("invited"),
  /** The account name of the guild member who generated this log entry. */
  user: z.string(),
  /** Account name of the guild member which invited the player. */
  invited_by: z.string()
});
var GuildLogKickDTO = z.object({
  /** The type of log entry. */
  type: z.literal("kick"),
  /** The account name of the guild member who generated this log entry. */
  user: z.string(),
  /** Account name of the guild member which kicked the player. */
  kicked_by: z.string()
});
var GuildLogRankChangeDTO = z.object({
  /** The type of log entry. */
  type: z.literal("rank_change"),
  /** The account name of the guild member who generated this log entry. */
  user: z.string(),
  /** Old rank name. */
  old_rank: z.string(),
  /** New rank name. */
  new_rank: z.string(),
  /** Account name of the guild member which changed the player rank. */
  changed_by: z.string().optional()
});
var GuildLogStashDTO = z.object({
  /** The type of log entry. */
  type: z.literal("stash"),
  /** Stash operation type. */
  operation: z.enum(["deposit", "withdraw", "move"]),
  /** The item ID that was deposited into the treasury. */
  item_id: z.number(),
  /** How many of the specified item was deposited. */
  count: z.number(),
  /** How many coins (in copper) were deposited. */
  coins: z.number()
});
var GuildLogMotdDTO = z.object({
  /** The type of log entry. */
  type: z.literal("motd"),
  /** The account name of the guild member who generated this log entry. */
  user: z.string(),
  /** The new message of the day. */
  motd: z.string()
});
var GuildLogUpgradeDTO = z.object({
  /** The type of log entry. */
  type: z.literal("upgrade"),
  /** The type of interaction had. */
  action: z.enum(["queued", "cancelled", "completed", "sped_up"]),
  /** If upgrade was completed, indicates how many upgrades were added. */
  count: z.number().optional(),
  /** The id of the completed upgrade. */
  upgrade_id: z.number(),
  /** May be added if the upgrade was created through a scribe station by a scribe. */
  recipe_id: z.number().optional()
});
var GuildLogDTO = z.array(
  z.object({
    /** An ID to uniquely identify the log entry within the scope of the guild. Not globally unique. */
    id: z.number(),
    /** ISO-8601 standard timestamp for when the log entry was created. */
    time: z.string()
  }).and(
    z.discriminatedUnion("type", [
      GuildLogJoinedDTO,
      GuildLogInvitedDTO,
      GuildLogKickDTO,
      GuildLogRankChangeDTO,
      GuildLogStashDTO,
      GuildLogMotdDTO,
      GuildLogUpgradeDTO
    ])
  )
);
var GuildMembersDTO = z.array(
  z.object({
    /** The account name of the member. */
    name: z.string(),
    /** The guild rank of the member. Can be resolved with /v2/guild/:id/ranks. */
    rank: z.string(),
    /** The time and date the member joined the guild (ISO-8601 standard). Was not tracked before around March 19th, 2013. */
    joined: z.union([z.string(), z.null()])
  })
);
var GuildRanksDTO = z.array(
  z.object({
    /** The id and name of the rank. */
    id: z.string(),
    /** A number given to each rank to specify how they should be sorted, lowest being the first and highest being the last. */
    order: z.number(),
    /** An array of permission ids from /v2/guild/permissions that have been given to this rank. */
    permissions: z.array(z.string()),
    /** The URL pointing to the image currently assigned to this rank. */
    icon: z.string()
  })
);
var GuildStashDTO = z.array(
  z.object({
    /** ID of the guild upgrade that granted access to this section of the guild vault. */
    upgrade_id: z.number(),
    /** The number of slots in this section of the guild vault. */
    size: z.number(),
    /** The number of coins deposited in this section of the guild vault. */
    coins: z.number(),
    /** The description set for this section of the guild's vault. */
    note: z.string(),
    /**
     * An array of objects describing the items in the guild stash of exactly size length.
     * Each object either contains the following properties if an item is present, or is null if the slot is empty.
     */
    inventory: z.array(
      z.union([
        z.null(),
        z.object({
          /** ID of the item in this slot. */
          id: z.number(),
          /** Amount of items in this slot. */
          count: z.number()
        })
      ])
    )
  })
);
var GuildStorageDTO = z.array(
  z.object({
    /** The id of the consumable. */
    id: z.number(),
    /** Amount of the consumable in storage. */
    count: z.number()
  })
);
var PvPAggregate = z.object({
  /** The wins for the category. */
  wins: z.number(),
  /** The losses for the category. */
  losses: z.number(),
  /** The desertions for the category. */
  desertions: z.number(),
  /** The byes for the category. */
  byes: z.number(),
  /** The forfeit for the category. */
  forfeits: z.number()
});
var PvPGame = z.object({
  /** The game's UUID. */
  id: z.string(),
  /** The map the match was played on. Can be resolved against /v2/maps. */
  map_id: z.string(),
  /** A timestamp of when the match started. */
  started: z.string(),
  /** A timestamp of when the match ended. */
  ended: z.string(),
  /** The team the player was on during the match. */
  team: z.string(),
  /** Team scores. */
  scores: z.object({
    /** The ending score of the red team. */
    red: z.number(),
    /** The ending score of the blue team. */
    blue: z.number()
  }),
  /** The type of game mode played. */
  rating_type: z.enum(["Ranked", "Unranked", "None"]),
  /** Change in rating as a result of the observed game. Note that number can be negative in the case of a loss. */
  rating_change: z.number(),
  /** Season id. Can be resolved against /v2/pvp/season. */
  season: z.string().optional()
});
var GuildTeamsDTO = z.array(
  z.object({
    /** the team ID, only unique within a guild. */
    id: z.number(),
    /** Array of members in the team. */
    members: z.array(
      z.object({
        /** Matching name from /v2/guild/members. */
        name: z.string(),
        /** Captain or member. */
        role: z.enum(["Member", "Captain"])
      })
    ),
    /** Team name. */
    name: z.string(),
    /** Team statistics aggregate. */
    aggregate: PvPAggregate,
    /** Team ladder statistics aggregates. */
    ladders: z.object({
      /** Ranked arena stats. */
      ranked: PvPAggregate.optional(),
      /** Unranked arena stats. */
      unranked: PvPAggregate.optional()
    }),
    /** Team games. */
    games: z.array(PvPGame),
    /** Team's seasonal participation. */
    seasons: z.array(
      z.object({
        /** Season id. */
        id: z.string(),
        /** Win count. */
        wins: z.number(),
        /** Loss count. */
        losses: z.number(),
        /** Seasonal rating. */
        rating: z.number()
      })
    ).optional()
  })
);
var GuildTreasuryDTO = z.array(
  z.object({
    /** The item id. */
    item_id: z.number(),
    /** How many items are currently in the treasury. */
    count: z.number(),
    /** An array of objects describing which currently in-progress upgrades are needing this item. */
    needed_by: z.array(
      z.object({
        /** The ID of the upgrade needing this item. */
        upgrade_id: z.number(),
        /** The total amount the upgrade needs for this item. */
        count: z.number()
      })
    )
  })
);
var GuildUpgradesDTO = z.array(
  /** The id of the upgrade. */
  z.number()
);
var GuildUpgradesInfoDTO = z.array(
  z.object({
    /** The upgrade id. */
    id: z.number(),
    /** The name of the upgrade. */
    name: z.string(),
    /** The guild upgrade description. */
    description: z.string(),
    /** A URL pointing to an icon for the upgrade. */
    icon: z.string(),
    /** The time it takes to build the upgrade. */
    build_time: z.number(),
    /** The prerequisite level the guild must be at to build the upgrade. */
    required_level: z.number(),
    /** The amount of guild experience that will be awarded upon building the upgrade. */
    experience: z.number(),
    /** An array of upgrade IDs that must be completed before this can be built. */
    prerequisites: z.array(z.number()),
    /** An array of objects describing the upgrade's cost. */
    costs: z.array(
      z.discriminatedUnion("type", [
        z.object({
          /** The type of cost. */
          type: z.literal("Item"),
          /** The id of the item, if applicable, can be resoled against v2/items. */
          item_id: z.number().optional(),
          /** The name of the cost. */
          name: z.string(),
          /** The amount needed. */
          count: z.number()
        }),
        z.object({
          /** The type of cost. */
          type: z.literal("Collectible"),
          /** The id of the item, if applicable, can be resoled against v2/items. */
          item_id: z.number().optional(),
          /** The name of the cost. */
          name: z.string(),
          /** The amount needed. */
          count: z.number()
        }),
        z.object({
          /** The type of cost. */
          type: z.literal("Currency"),
          /** The name of the cost. */
          name: z.string(),
          /** The amount needed. */
          count: z.number()
        }),
        z.object({
          /** The type of cost. */
          type: z.literal("Coins"),
          /** The amount needed. */
          count: z.number()
        })
      ])
    )
  }).and(
    z.discriminatedUnion("type", [
      z.object({
        /** The upgrade type. */
        type: z.literal("AccumulatingCurrency")
      }),
      z.object({
        /** The upgrade type. */
        type: z.literal("Boost")
      }),
      z.object({
        /** The upgrade type. */
        type: z.literal("Claimable")
      }),
      z.object({
        /** The upgrade type. */
        type: z.literal("Consumable")
      }),
      z.object({
        /** The upgrade type. */
        type: z.literal("Decoration")
      }),
      z.object({
        /** The upgrade type. */
        type: z.literal("GuildHall")
      }),
      z.object({
        /** The upgrade type. */
        type: z.literal("GuildHallExpedition")
      }),
      z.object({
        /** The upgrade type. */
        type: z.literal("Hub")
      }),
      z.object({
        /** The upgrade type. */
        type: z.literal("Queue")
      }),
      z.object({
        /** The upgrade type. */
        type: z.literal("Unlock")
      }),
      z.object({
        /** The upgrade type. */
        type: z.literal("BankBag"),
        /** The maximum item slots of the guild bank tab. */
        bag_max_items: z.number().optional(),
        /** The maximum amount of coins that can be stored in the bank tab. */
        bag_max_coins: z.number().optional()
      })
    ])
  )
);
var GuildPermissionsDTO = z.array(
  z.object({
    /** The permission id. */
    id: z.string(),
    /** The permission name. */
    name: z.string(),
    /** Description of the permission. */
    description: z.string()
  })
);
var GuildSearchDTO = z.array(
  /** The id of the guild. */
  z.string()
);
var HomeNodesDTO = z.array(
  z.object({
    /** Id of the node. */
    id: z.string()
  })
);
var HomeCatsDTO = z.array(
  z.object({
    /** Id of the cat. */
    id: z.number(),
    /* A hint to identify what is needed for each cat. */
    hint: z.string().optional()
  })
);
var HomesteadDecorationsDTO = z.array(
  z.object({
    /** The decoration id. */
    id: z.number(),
    /* The name of the decoration. */
    name: z.string(),
    /** The homestead decoration description. */
    description: z.string(),
    /** The maximum amount of storable instances of this decoration. */
    max_count: z.number(),
    /** A URL pointing to an icon for the decoration. */
    icon: z.string(),
    /** An array of decoration category ids which this decoration belongs to.
     * Can be compared to the v2/homestead/decorations/categories endpoint */
    categories: z.array(z.number())
  })
);
var HomesteadDecorationsCategoriesDTO = z.array(
  z.object({
    /** The category's ID. */
    id: z.number(),
    /** The category name. */
    name: z.string()
  })
);
var HomesteadGlyphsDTO = z.array(
  z.object({
    /** The homestead glyph id. */
    id: z.string(),
    /** The id of the glyph item.
     * Can be compared to the /v2/items endpoint. */
    item_id: z.number(),
    /** The slot it is attached to. */
    slot: z.enum(["harvesting", "mining", "logging"])
  })
);
var BuildDTO = z.object({
  /** The id of the current game build. */
  id: z.number()
});
var MaterialColorData = z.object({
  /** Color brightness. */
  brightness: z.number(),
  /** Color contrast. */
  contrast: z.number(),
  /** Color hue. */
  hue: z.number(),
  /** Color saturation. */
  saturation: z.number(),
  /** Color lightness. */
  lightness: z.number(),
  /** Color RGB values. */
  rgb: z.array(z.number()).length(3)
});
var Hue = z.enum(["Gray", "Brown", "Red", "Orange", "Yellow", "Green", "Blue", "Purple"]);
var Material = z.enum(["Vibrant", "Leather", "Metal"]);
var Rarity = z.enum(["Starter", "Common", "Uncommon", "Rare", "Exclusive"]);
var ColorsDTO = z.array(
  z.object({
    /** The color id. */
    id: z.number(),
    /** The color name. */
    name: z.string(),
    /** The base RGB values. */
    base_rgb: z.array(z.number()).length(3),
    /** Detailed information on its appearance when applied on cloth armor. */
    cloth: MaterialColorData,
    /** Detailed information on its appearance when applied on leather armor. */
    leather: MaterialColorData,
    /** Detailed information on its appearance when applied on metal armor. */
    metal: MaterialColorData,
    /** Detailed information on its appearance when applied on fur armor. */
    fur: MaterialColorData.optional(),
    /** ID of the dye item. */
    item: z.number().optional(),
    /** Color categories. */
    categories: z.tuple([Hue, Material, Rarity]).or(z.array(z.undefined()).length(0))
  })
);
var EmblemDTO = z.array(
  z.object({
    /** The emblem id. */
    id: z.number(),
    /** An array of URLs to images that make up the various parts of the emblem. */
    layers: z.array(z.string())
  })
);
var EmotesDTO = z.array(
  z.object({
    /** Id of the emote. */
    id: z.string(),
    /** List of all available commands for the emote. */
    commands: z.array(z.string()),
    /** List of ids of the items. Can be resolved against /v2/items. */
    unlock_items: z.array(z.number())
  })
);
var CurrenciesDTO = z.array(
  z.object({
    /** Currency id. */
    id: z.number(),
    /** Currency name. */
    name: z.string(),
    /** Currency description. */
    description: z.string(),
    /** Order of the currency in the list. */
    order: z.number(),
    /** Currency icon url. */
    icon: z.string()
  })
);
z.array(
  /** Name of the daily craftable item. */
  z.string()
);
var DungeonsDTO = z.array(
  z.object({
    /** The name of the dungeon.*/
    id: z.string(),
    /** The paths in the dungeon. */
    paths: z.array(
      z.object({
        /** The given name for the dungeon path. */
        id: z.string(),
        /** The type of the chosen path. */
        type: z.enum(["Story", "Explorable"])
      })
    )
  })
);
var FilesDTO = z.array(
  z.object({
    /** The file identifier. */
    id: z.string(),
    /** The URL to the image. */
    icon: z.string()
  })
);
var FinishersDTO = z.array(
  z.object({
    /** The id of the finisher. */
    id: z.number(),
    /** A description explaining how to acquire the finisher. */
    unlock_details: z.string(),
    /** An array of item ids used to unlock the finisher. Can be resolved against v2/items */
    unlock_items: z.array(z.number()).optional(),
    /** The order in which the finisher appears in a list. */
    order: z.number(),
    /** The icon uri for the finisher. */
    icon: z.string(),
    /** The name of the finisher as it appears in-game. */
    name: z.string()
  })
);
var GlidersDTO = z.array(
  z.object({
    /** The id of the glider. */
    id: z.number(),
    /** An array of item ids used to unlock the glider. Can be resolved against /v2/items. */
    unlock_items: z.array(z.number()).optional(),
    /** The order in which the glider appears in a list. The value is not unique. */
    order: z.number(),
    /** The icon URL for the glider. */
    icon: z.string(),
    /** The name of the glider as it appears in-game. */
    name: z.string(),
    /** The in-game glider description. */
    description: z.string(),
    /** List of dye ids. Can be resolved against /v2/colors. */
    default_dyes: z.array(z.number())
  })
);
var ItemType = z.enum([
  "Armor",
  "Back",
  "Bag",
  "Consumable",
  "Container",
  "CraftingMaterial",
  "Gathering",
  "Gizmo",
  "JadeTechModule",
  "Key",
  "MiniPet",
  "PowerCore",
  "Tool",
  "Trait",
  "Trinket",
  "Trophy",
  "UpgradeComponent",
  "Weapon"
]);
var ItemRarity = z.enum(["Junk", "Basic", "Fine", "Masterwork", "Rare", "Exotic", "Ascended", "Legendary"]);
var ItemFlags = z.enum([
  "AccountBindOnUse",
  "AccountBound",
  "Attuned",
  "BulkConsume",
  "DeleteWarning",
  "HideSuffix",
  "Infused",
  "MonsterOnly",
  "NoMysticForge",
  "NoSalvage",
  "NoSell",
  "NotUpgradeable",
  "NoUnderwater",
  "SoulbindOnAcquire",
  "SoulBindOnUse",
  "Tonic",
  "Unique"
]);
var ItemGameTypes = z.enum(["Activity", "Dungeon", "Pve", "Pvp", "Wvw", "PvpLobby"]);
var ItemRestrictions = z.enum([
  "Asura",
  "Charr",
  "Female",
  "Human",
  "Norn",
  "Sylvari",
  "Elementalist",
  "Engineer",
  "Guardian",
  "Mesmer",
  "Necromancer",
  "Ranger",
  "Thief",
  "Warrior"
]);
var ItemUpgrade = z.object({
  /** Describes the method of upgrading. */
  upgrade: z.enum(["Attunement", "Infusion"]),
  /** The item ID that results from performing the upgrade. */
  item_id: z.number()
});
var Attribute = z.object({
  /** Attribute this bonus applies to. */
  attribute: z.enum([
    "AgonyResistance",
    "BoonDuration",
    "ConditionDamage",
    "ConditionDuration",
    "CritDamage",
    "Healing",
    "Power",
    "Precision",
    "Toughness",
    "Vitality"
  ]),
  /** The modifier value. */
  modifier: z.number()
});
var InfixUpgrade = z.object({
  /** The itemstat id. Can be resolved against /v2/itemstats.
   * The usual whitelist restrictions apply, and not all itemstats may be visible. */
  id: z.number(),
  /** List of attribute bonuses. */
  attributes: z.array(Attribute),
  /** Object containing an additional effect.
   * This is used for Boon Duration, Condition Duration,
   * or additional attribute bonuses for ascended trinkets or back items. */
  buff: z.object({
    /** The skill id of the effect. */
    skill_id: z.number(),
    /** The effect's description. */
    description: z.string().optional()
  }).optional()
});
var InfusionSlot = z.object({
  /**
   * Infusion slot type of infusion upgrades.
   * The array contains a maximum of one value
   */
  flags: z.array(z.enum(["Enrichment", "Infusion"])).max(1),
  /**
   * The infusion upgrade already in the armor piece.
   */
  item_id: z.number().optional()
});
var ArmorDetails = z.object({
  /** The armor slot type. */
  type: z.enum(["Boots", "Coat", "Gloves", "Helm", "HelmAquatic", "Leggings", "Shoulders"]),
  /** The weight class of the armor piece. */
  weight_class: z.enum(["Heavy", "Medium", "Light", "Clothing"]),
  /** The defense value of the armor piece. */
  defense: z.number(),
  /** Infusion slots of the armor piece. */
  infusion_slots: z.array(InfusionSlot),
  /** The value used to calculate attributes. See /v2/itemstats. */
  attribute_adjustments: z.number(),
  /** The infix upgrade. */
  infix_upgrade: InfixUpgrade.optional()
});
var BackItemDetails = z.object({
  /** Infusion slots of the back item. */
  infusion_slots: z.array(InfusionSlot),
  /** The value used to calculate attributes. See /v2/itemstats. */
  attribute_adjustments: z.number().optional(),
  /** The infix upgrade. */
  infix_upgrade: InfixUpgrade.optional(),
  /** The id of the item suffix. */
  suffix_item_id: z.number().optional(),
  /** The secondary id of the item suffix. */
  secondary_suffix_item_id: z.string(),
  /** Selectable stat ids. Can be resolved by /v2/itemstats */
  stat_choices: z.array(z.number()).optional()
});
var BagDetails = z.object({
  /** The number of bag slots. */
  size: z.number(),
  /** Whether the bag is invisible or safe. */
  no_sell_or_sort: z.boolean()
});
var ConsumableType = z.enum([
  "AppearanceChange",
  "Booze",
  "ContractNpc",
  "Currency",
  "Food",
  "Generic",
  "Halloween",
  "Immediate",
  "MountRandomUnlock",
  "RandomUnlock",
  "Transmutation",
  "Unlock",
  "UpgradeRemoval",
  "Utility",
  "TeleportToFriend"
]);
var UnlockType = z.enum([
  "BagSlot",
  "BankTab",
  "Champion",
  "CollectibleCapacity",
  "Content",
  "CraftingRecipe",
  "Dye",
  "GliderSkin",
  "Minipet",
  "Ms",
  "Outfit",
  "RandomUnlock",
  "SharedSlot"
]);
var ConsumableDetails = z.object({
  /** Consumable type. */
  type: ConsumableType,
  /** Effect description for consumables applying an effect. */
  description: z.string().optional(),
  /** Effect duration, in milliseconds. */
  duration_ms: z.number().optional(),
  /** Unlock type for unlock consumables */
  unlock_type: UnlockType.optional(),
  /** The dye id for dye unlocks. */
  color_id: z.number().optional(),
  /** The recipe id for recipe unlocks. */
  recipe_id: z.number().optional(),
  /** Additional recipe ids for recipe unlocks */
  extra_recipe_ids: z.array(z.number()).optional(),
  /** The guild upgrade id for the item. Can be resolved by /v2/guild/upgrades. */
  guild_upgrade_id: z.number().optional(),
  /** The number of stacks of the effect applied by this item. */
  apply_count: z.number().optional(),
  /** The effect type name of the consumable. */
  name: z.string().optional(),
  /** The icon of the effect. */
  icon: z.string().optional(),
  /** A list of skin ids which this item unlocks. Can be resolved by /v2/skins. */
  skins: z.array(z.number()).optional()
});
var ContainerDetails = z.object({
  /** Container type. */
  type: z.enum(["Default", "GiftBox", "Immediate", "OpenUI"])
});
var GatheringDetails = z.object({
  /** Gathering utility type. */
  type: z.enum(["Foraging", "Logging", "Mining", "Bait", "Lure"])
});
var GizmoDetails = z.object({
  /** Gizmo type. */
  type: z.enum(["Default", "ContainerKey", "RentableContractNpc", "UnlimitedConsumable"]),
  /** The id of the guild decoration, which can be deposited. Can be resolved by /v2/guild/upgrades. */
  guild_upgrade_id: z.number().optional(),
  /** Vendor ids of the gizmo. */
  vendor_ids: z.array(z.number()).optional()
});
var MiniatureDetails = z.object({
  /** The miniature this item unlocks. Can be resolved by /v2/minis. */
  minipet_id: z.number()
});
var SalvageKitDetails = z.object({
  /** The tool type. Always the same value. */
  type: z.literal("Salvage"),
  /** Number of charges. */
  charges: z.number()
});
var TrinketDetails = z.object({
  /** The trinket type. */
  type: z.enum(["Accessory", "Amulet", "Ring"]),
  /** Infusion slots of the trinket. */
  infusion_slots: z.array(InfusionSlot),
  /** The value used to calculate attributes. See /v2/itemstats */
  attribute_adjustments: z.number(),
  /** The infix upgrade. */
  infix_upgrade: InfixUpgrade.optional(),
  /** The id of the item suffix. */
  suffix_item_id: z.number().optional(),
  /** The secondary id of the item suffix. */
  secondary_suffix_item_id: z.string(),
  /** Selectable stat ids. Can be resolved by /v2/itemstats */
  stat_choices: z.array(z.number()).optional()
});
var TrophyAndCraftingDetails = z.undefined();
var UpgradeComponentFlags = z.enum([
  "Axe",
  "Dagger",
  "Focus",
  "Greatsword",
  "Hammer",
  "Harpoon",
  "LongBow",
  "Mace",
  "Pistol",
  "Rifle",
  "Scepter",
  "Shield",
  "ShortBow",
  "LongBow",
  "Speargun",
  "Staff",
  "Sword",
  "Torch",
  "Trident",
  "Warhorn",
  "HeavyArmor",
  "MediumArmor",
  "LightArmor",
  "Trinket"
]);
var UpgradeComponentDetails = z.object({
  /** The upgrade component type. */
  type: z.enum(["Default", "Gem", "Rune", "Sigil"]),
  /** The items that can be upgraded with the upgrade component. */
  flags: z.array(UpgradeComponentFlags),
  /** Applicable infusion slot for infusion upgrades. */
  infusion_upgrade_flags: z.array(z.enum(["Enrichment", "Infusion"])),
  /** The suffix appended to the item name when the component is applied. */
  suffix: z.string().optional(),
  /** The infix upgrade object. */
  infix_upgrade: InfixUpgrade,
  /** The bonuses from runes. */
  bonuses: z.array(z.string()).optional()
});
var WeaponType = z.enum([
  "Axe",
  "Dagger",
  "Mace",
  "Pistol",
  "Scepter",
  "Sword",
  "Focus",
  "Shield",
  "Torch",
  "Warhorn",
  "Greatsword",
  "Hammer",
  "LongBow",
  "Rifle",
  "ShortBow",
  "Staff",
  "Harpoon",
  "Speargun",
  "Trident",
  "LargeBundle",
  "SmallBundle",
  "Toy",
  "ToyTwoHanded"
]);
var WeaponDetails = z.object({
  /** The weapon type. */
  type: WeaponType,
  /** The damage type. */
  damage_type: z.enum(["Fire", "Ice", "Lightning", "Physical", "Choking"]),
  /** Minimum weapon power. */
  min_power: z.number(),
  /** Maximum weapon power; */
  max_power: z.number(),
  /** The defense value of the weapon. */
  defense: z.number(),
  /** Infusion slots of the trinket. */
  infusion_slots: z.array(InfusionSlot),
  /** The value used to calculate attributes. See /v2/itemstats. */
  attribute_adjustments: z.number(),
  /** The infix upgrade. */
  infix_upgrade: InfixUpgrade.optional(),
  /** The id of the item suffix. */
  suffix_item_id: z.number().optional(),
  /** The secondary id of the item suffix. */
  secondary_suffix_item_id: z.string(),
  /** Selectable stat ids. Can be resolved by /v2/itemstats */
  stat_choices: z.array(z.number()).optional()
});
var ItemsDTO = z.array(
  z.object({
    /** The item id. */
    id: z.number(),
    /** The chat link. */
    chat_link: z.string(),
    /** The item name. */
    name: z.string(),
    /** The full icon url. */
    icon: z.string().optional(),
    /** The item description. */
    description: z.string().optional(),
    /** The item type. */
    type: ItemType,
    /** The item rarity. */
    rarity: ItemRarity,
    /** The required level. */
    level: z.number(),
    /** The value in coins when selling to a vendor.
     * Note: Can be non-zero even when the item has the NoSell flag. */
    vendor_value: z.number(),
    /** The default skin id. */
    default_skin: z.number().optional(),
    /** Flags applying to the item. */
    flags: z.array(ItemFlags),
    /** The game types in which the item is usable.
     * At least one game type is specified. */
    game_types: z.array(ItemGameTypes),
    /** Restrictions applied to the item. */
    restrictions: z.array(ItemRestrictions),
    /** Lists what items this item can be upgraded into, and the method of upgrading. */
    upgrades_into: z.array(ItemUpgrade).optional(),
    /** Lists what items this item can be upgraded from, and the method of upgrading. */
    upgrades_from: z.array(ItemUpgrade).optional(),
    /** Additional item details, if applicable. */
    details: z.union([
      ArmorDetails,
      BackItemDetails,
      BagDetails,
      ConsumableDetails,
      ContainerDetails,
      GatheringDetails,
      GizmoDetails,
      MiniatureDetails,
      SalvageKitDetails,
      TrinketDetails,
      TrophyAndCraftingDetails,
      UpgradeComponentDetails,
      WeaponDetails
    ])
  })
);
var Attributes = z.enum([
  "AgonyResistance",
  "BoonDuration",
  "ConditionDamage",
  "ConditionDuration",
  "CritDamage",
  "Healing",
  "Power",
  "Precision",
  "Toughness",
  "Vitality"
]);
var Attribute2 = z.object({
  /** The name of the attribute. */
  attribute: Attributes,
  /** The multiplier number for that attribute. */
  multiplier: z.number(),
  /** The value number for that attribute. */
  value: z.number()
});
var ItemStatsDTO = z.array(
  z.object({
    /** The itemstat id. */
    id: z.number(),
    /** The name of the set of stats. */
    name: z.string(),
    /** The list of bonus attributes. */
    attributes: z.array(Attribute2)
  })
);
var JadebotsDTO = z.array(
  z.object({
    /** The id of the jade bot skin. */
    id: z.number(),
    /** The name of the jade bot skin. */
    name: z.string(),
    /** A description of how to unlock the skin. */
    description: z.string(),
    /** The item which unlocks the skin. Can be resolved against /v2/items */
    unlock_item: z.number()
  })
);
var LegendaryArmoryDTO = z.array(
  z.object({
    /** The item id of the legendary armory item. */
    id: z.number(),
    /** The maximum quantity of the legendary armory item that can be stored on the account. */
    max_count: z.union([z.literal(1), z.literal(2), z.literal(4), z.literal(7), z.literal(8)])
  })
);
var LegendsDTO = z.array(
  z.object({
    /** Id of the legend. */
    id: z.string(),
    /** The legend code for a build template link. Available on schema version 2019-12-19T00:00:00.000Z or later. */
    code: z.number().optional(),
    /** The id of the profession (swap Legend) skill. Can be resolved against /v2/skills. */
    swap: z.number(),
    /** The id of the heal skill. Can be resolved against /v2/skills. */
    heal: z.number(),
    /** The id of the elite skill. Can be resolved against /v2/skills. */
    elite: z.number(),
    /** The ids of the utility skills. Can be resolved against /v2/skills. */
    utilities: z.array(z.number())
  })
);
var MailCarriersDTO = z.array(
  z.object({
    /** The id of the mail carrier. */
    id: z.number(),
    /** An array of item ids used to unlock the mailcarrier. Can be resolved against /v2/items. */
    unlock_items: z.array(z.number()),
    /** The order in which the mailcarrier appears in a list. */
    order: z.number(),
    /** The icon uri for the mail carrier. */
    icon: z.string(),
    /** The name of the mailcarrier as it appears in-game. */
    name: z.string(),
    /** Additional flags on the item, such as "Default" */
    flags: z.array(z.string())
  })
);
var MapChestsDTO = z.array(
  /** The map chest id. */
  z.string()
);
var MapsDTO = z.array(
  z.object({
    /** The map id. */
    id: z.number(),
    /** The map name. */
    name: z.string(),
    /** The minimal level for this map. */
    min_level: z.number(),
    /** The maximum level for this map. */
    max_level: z.number(),
    /** The default floor for this map. */
    default_floor: z.number(),
    /** The map type. */
    type: z.enum([
      "BlueHome",
      "Center",
      "EdgeOfTheMists",
      "GreenHome",
      "Instance",
      "JumpPuzzle",
      "Public",
      "Pvp",
      "RedHome",
      "Tutorial",
      "Unknown"
    ]),
    /** A list of available floors for this map. */
    floors: z.array(z.number()),
    /** The id of the region this map belongs to. */
    region_id: z.number().optional(),
    /** The name of the region this map belongs to. */
    region_name: z.string().optional(),
    /** The id of the continent this map belongs to. */
    continent_id: z.number().optional(),
    /** The name of the continent this map belongs to. */
    continent_name: z.string().optional(),
    /** The dimensions of the map, given as the coordinates of the lower-left (SW) and upper-right (NE) corners. */
    map_rect: z.array(z.array(z.number())),
    /** The dimensions of the map within the continent coordinate system, given as the coordinates of the upper-left (NW) and lower-right (SE) corners. */
    continent_rect: z.array(z.array(z.number()))
  })
);
var MaterialsDTO = z.array(
  z.object({
    /** The category id. */
    id: z.number(),
    /** The category name. */
    name: z.string(),
    /** The ids of the items in this category. Can be resolved against /v2/items. */
    items: z.array(z.number()),
    /** The order in which the category appears in the material storage. */
    order: z.number()
  })
);
var Levels = z.object({
  /** The name for the given mastery. */
  name: z.string(),
  /** The in game description for the given mastery. */
  description: z.string(),
  /** The in game instructions for the given mastery. */
  instruction: z.string(),
  /** The icon uri for the mastery. */
  icon: z.string(),
  /** The amount of mastery points required to unlock the mastery. */
  point_cost: z.number(),
  /** The total amount of experience needed to train the given mastery level. This total is non-cumulative between levels. */
  exp_cost: z.number()
});
var MasteriesDTO = z.array(
  z.object({
    /** The id of the mastery. */
    id: z.number(),
    /** The name of the selected mastery. */
    name: z.string(),
    /** The written out requirements to unlock the mastery track. */
    requirement: z.string(),
    /** The order in which the mastery track appears in a list. */
    order: z.number(),
    /** The background uri for the mastery track. */
    background: z.string(),
    /** The in-game region in which the mastery track belongs. */
    region: z.string(),
    /** An array containing the information of each mastery level. */
    levels: z.array(Levels)
  })
);
var MinisDTO = z.array(
  z.object({
    /** The mini id. */
    id: z.number(),
    /** The mini name. */
    name: z.string(),
    /** A description of how to unlock the mini (only present on a few entries). */
    unlock: z.string().optional(),
    /** The mini icon. */
    icon: z.string(),
    /** The sort order that is used for displaying the mini in-game. */
    order: z.number(),
    /** The item which unlocks the mini. Can be resolved against /v2/items. */
    item_id: z.number()
  })
);
var NoveltiesDTO = z.array(
  z.object({
    /** The id of the novelty. */
    id: z.number(),
    /** The name of the novelty as it appears in-game. */
    name: z.string(),
    /** The in-game novelty description. */
    description: z.string(),
    /** The icon url for the novelty. */
    icon: z.string(),
    /** The slot which the novelty appears in the UI for. */
    slot: z.enum(["Chair", "Music", "HeldItem", "Miscellaneous", "Tonic"]),
    /** An array of item ids used to unlock the novelty. Can be resolved against /v2/items. */
    unlock_item: z.array(z.number())
  })
);
var OutfitsDTO = z.array(
  z.object({
    /** The id of the outfit. */
    id: z.number(),
    /** The name of the outfit (this is also the outfit displayed over a character in-game.) */
    name: z.string(),
    /** The icon for the selected outfit. */
    icon: z.string(),
    /** An array of item id which unlock this outfit; Can be resolved against v2/items. */
    unlock_items: z.array(z.number())
  })
);
var PetsDTO = z.array(
  z.object({
    /** The id of the pet. */
    id: z.number(),
    /** The name of the pet. */
    name: z.string(),
    /** The description of the pet. */
    description: z.string(),
    /** The icon uri for the pet. */
    icon: z.string(),
    /** List of skill ids. Can be resolved against /v2/skills. */
    skills: z.array(
      z.object({
        /** The id of the skill. */
        id: z.number()
      })
    )
  })
);
var Weapon = z.enum([
  "Axe",
  "Dagger",
  "Mace",
  "Pistol",
  "Sword",
  "Scepter",
  "Focus",
  "Shield",
  "Torch",
  "Warhorn",
  "Greatsword",
  "Hammer",
  "Longbow",
  "Rifle",
  "Shortbow",
  "Staff",
  "Speargun",
  "Spear",
  "Trident"
]);
var ProfessionsDTO = z.array(
  z.object({
    /** The profession id. */
    id: z.string(),
    /** The name of the profession. */
    name: z.string(),
    /** The profession code for a build template link. */
    code: z.number().optional(),
    /** The icon for the profession. */
    icon: z.string(),
    /** The large icon for the profession. */
    icon_big: z.string(),
    /** The specialization ids. Can be resolved against /v2/specializations. */
    specializations: z.array(z.number()),
    /** List of training details. */
    training: z.array(
      z.object({
        /** The id of the skill or specialization. Can be resolved against /v2/skills and /v2/specializations. */
        id: z.number(),
        /** The category for the training object. */
        category: z.enum(["Skills", "Specializations", "EliteSpecializations"]),
        /** The name of the skill or specialization indicated by the category and id. */
        name: z.string(),
        /** List of skills and traits training details tracks objects. */
        track: z.array(
          z.object({
            /** The cost to train this skill or trait. */
            cost: z.number()
          }).and(
            z.discriminatedUnion("type", [
              z.object({
                /** Whether this is a skill or trait. */
                type: z.literal("Trait"),
                /** The trait id. Can be resolved against /v2/traits. */
                trait_id: z.number()
              }),
              z.object({
                /** Whether this is a skill or trait. */
                type: z.literal("Skill"),
                /** The skill id. Can be resolved against /v2/skills. */
                skill_id: z.number()
              })
            ])
          )
        )
      })
    ),
    // weapons (object) - The weapons available for this profession. The key indicates the weapon type, which is one of the following:
    weapons: z.record(
      Weapon,
      z.object({
        /** Weapon slot flag. */
        flag: z.array(z.enum(["Mainhand", "Offhand", "TwoHand", "Aquatic"])).optional(),
        /** The specializations id of the required specialization to use this weapon.
         * Can be resolved against /v2/specializations. Only present if a specialization is required. */
        specialization: z.number().optional(),
        /** The list of weapon skills objects. */
        skills: z.array(
          z.object({
            /** The skill id. Can be resolved against /v2/skills. */
            id: z.number(),
            /** The skill bar slot that this weapon skill can be used in. */
            slot: z.union([
              z.enum(["Profession_1", "Utility", "Heal", "Elite"]),
              z.custom(
                (val) => typeof val === "string" ? /^Weapon_[1-5]$/.test(val) : false
              )
            ]),
            /** The name of the offhand weapon this skill requires to be equipped. This field is usually only present for Thief skills. */
            offhand: z.string().optional(),
            /** The Elementalist attunement that this skill requires. This field is usually only present for Elementalist skills. */
            attunement: z.string().optional(),
            /** The name of the class the skill was stolen from. This only applies to thief stolen skills. */
            source: z.string().optional()
          })
        )
      })
    ),
    /** Profession flags. */
    flags: z.array(z.enum(["NoRacialSkills", "NoWeaponSwap"])),
    /** The first number is a skill palette ID obtained from a build template link, the second number is a skill ID.
     * Can be resolved against /v2/skills. */
    skills_by_palette: z.array(z.number()).length(2).optional()
  })
);
var QuaggansDTO = z.array(
  z.object({
    /** The quaggan identifier. */
    id: z.string(),
    /** The URL to the quaggan image. */
    url: z.string()
  })
);
var QuestsDTO = z.array(
  z.object({
    /** The id of the quest. */
    id: z.number(),
    /** The name of the quest. */
    name: z.string(),
    /** The minimum level required for a character to begin this quest. */
    level: z.number(),
    /** The id for the story. Can be resolved against /v2/stories. */
    story: z.number(),
    /** An array of goal objects providing details about the goals for this quest. */
    goals: z.array(
      z.object({
        /** The text displayed for the quest step if it is active. */
        active: z.string(),
        /** The text displayed for the quest step if it is complete. */
        complete: z.string()
      })
    )
  })
);
var RacesDTO = z.array(
  z.object({
    /** The id/name of the race. */
    id: z.string(),
    /** An array of skill ids. Can be resolved against v2/skills. */
    skills: z.array(z.number())
  })
);
var RaidsDTO = z.array(
  z.object({
    /** The name of the dungeon. */
    id: z.string(),
    /** An array of object containing the following: */
    wings: z.array(
      z.object({
        /** The given name for the dungeon path. */
        id: z.string(),
        /** List of events within the raid or dungeon. */
        events: z.array(
          z.object({
            /** The event/encounter name. */
            id: z.string(),
            /** The type of events. */
            type: z.enum(["Checkpoint", "Boss"])
          })
        )
      })
    )
  })
);
var WeaponRecipes = z.enum([
  "Axe",
  "Dagger",
  "Focus",
  "Greatsword",
  "Hammer",
  "Harpoon",
  "LongBow",
  "Mace",
  "Pistol",
  "Rifle",
  "Scepter",
  "Shield",
  "ShortBow",
  "Speargun",
  "Staff",
  "Sword",
  "Torch",
  "Trident",
  "Warhorn"
]);
var ArmorRecipes = z.enum(["Boots", "Coat", "Gloves", "Helm", "Leggings", "Shoulders"]);
var TrinketRecipes = z.enum(["Amulet", "Earring", "Ring"]);
var FoodRecipes = z.enum(["Dessert", "Feast", "IngredientCooking", "Meal", "Seasoning", "Snack", "Soup", "Food"]);
var CraftingComponentRecipes = z.enum(["Component", "Inscription", "Insignia", "LegendaryComponent"]);
var RefinementRecipes = z.enum(["Refinement", "RefinementEctoplasm", "RefinementObsidian"]);
var GuildRecipes = z.enum(["GuildConsumable", "GuildDecoration", "GuildConsumableWvw"]);
var OtherRecipes = z.enum(["Backpack", "Bag", "Bulk", "Consumable", "Dye", "Food", "Potion", "UpgradeComponent"]);
var RecipesDTO = z.array(
  z.object({
    /** The recipe id. */
    id: z.number(),
    /** The recipe type. */
    type: z.union([
      WeaponRecipes,
      ArmorRecipes,
      TrinketRecipes,
      FoodRecipes,
      CraftingComponentRecipes,
      RefinementRecipes,
      GuildRecipes,
      OtherRecipes
    ]),
    /** The item id of the produced item. Can be resolved against /v2/items. */
    output_item_id: z.number(),
    /** The amount of items produced. */
    output_item_count: z.number(),
    /** The time in milliseconds it takes to craft the item. */
    time_to_craft_ms: z.number(),
    /** The crafting disciplines that can use the recipe. */
    disciplines: z.array(
      z.enum([
        "Artificer",
        "Armorsmith",
        "Chef",
        "Huntsman",
        "Jeweler",
        "Leatherworker",
        "Tailor",
        "Weaponsmith",
        "Scribe"
      ])
    ),
    /** The required rating to craft the recipe. */
    min_rating: z.number(),
    /** Flags applying to the recipe. */
    flags: z.array(z.enum(["AutoLearned", "LearnedFromItem"])),
    /** List of recipe ingredients */
    ingredients: z.array(
      z.object({
        /** Type of ingredient. */
        type: z.enum(["Currency", "Item"]),
        /** The ingredient's id. Can be resolved against /v2/items or /v2/currencies, depending on type */
        id: z.number(),
        /** The quantity of this ingredient. */
        count: z.number()
      })
    ),
    /** List of recipe ingredients that come from the guild such as decorations or schematics. */
    guild_ingredients: z.array(
      z.object({
        /** The id of the used guild upgrade. Can be resolved against /v2/guild/upgrades. */
        upgrade_id: z.number(),
        /** The quantity of this guild ingredient. */
        count: z.number()
      })
    ).optional(),
    /** The id of the produced guild upgrade. Can be resolved against /v2/guild/upgrades. */
    output_upgrade_id: z.number().optional(),
    /** The chat code for the recipe. */
    chat_link: z.string()
  })
);
var SkiffsDTO = z.array(
  z.object({
    /** The id of the skiff skin. */
    id: z.number(),
    /** The name of the skiff skin. */
    name: z.string(),
    /** The full icon URL. */
    icon: z.string(),
    /** An object containing information on the available dye slots and defaults. */
    dye_slots: z.array(
      z.object({
        /** The id of the default color. Can be resolved against v2/colors. */
        color_id: z.number(),
        /** The type of material. */
        material: z.enum(["metal", "leather", "cloth"])
      })
    )
  })
);
var AttributeAdjust = z.object({
  type: z.literal("AttributeAdjust"),
  /** The amount target gets adjusted, based on a level 80 character at base stats. */
  value: z.number(),
  /** The attribute this fact adjusts. Note that a value of Healing indicates the fact is a heal skill, and Ferocity is encoded at CritDamage. */
  target: z.string()
});
var Buff = z.object({
  type: z.literal("Buff"),
  /** The boon, condition, or effect referred to by the fact. */
  status: z.string(),
  /** The description of the status effect. */
  description: z.string().optional(),
  /** The number of stacks applied. */
  apply_count: z.number().optional(),
  /** The duration of the effect in seconds. Note that some facts of this type are just used to display
   * the buff icon with text; in this case, duration is usually 0, or omitted entirely. */
  duration: z.number().optional()
});
var ComboField = z.object({
  type: z.literal("ComboField"),
  /** The type of field. */
  field_type: z.enum(["Air", "Dark", "Fire", "Ice", "Light", "Lightning", "Poison", "Smoke", "Ethereal", "Water"])
});
var Finisher = z.object({
  type: z.literal("ComboFinisher"),
  /** The type of finisher. */
  finisher_type: z.enum(["Blast", "Leap", "Projectile", "Whirl"]),
  /** The percent chance that the finisher will trigger. */
  percent: z.number()
});
var Damage = z.object({
  type: z.literal("Damage"),
  /** The amount of times the damage hits. */
  hit_count: z.number(),
  /** Indicates the damage multiplier value of that skill. */
  dmg_multiplier: z.number()
});
var Distance = z.object({
  type: z.literal("Distance"),
  /** The distance value. */
  distance: z.number()
});
var Duration = z.object({
  type: z.literal("Duration"),
  /** The duration in seconds. */
  duration: z.number()
});
var Heal = z.object({
  type: z.literal("Heal"),
  /** The number of times the heal skill is applied. */
  hit_count: z.number()
});
var HealingAdjust = z.object({
  type: z.literal("HealingAdjust"),
  /** The number of times the heal value is applied. */
  hit_count: z.number()
});
var NoData = z.object({
  /** This fact is usually used to display the Combat Only fact, but it can be used elsewhere. */
  type: z.literal("NoData")
});
var NumberType = z.object({
  type: z.literal("Number"),
  /** The number value as referenced by text. */
  value: z.number()
});
var Percent = z.object({
  type: z.literal("Percent"),
  /** The percentage value as referenced by text. */
  percent: z.number()
});
var PrefixedBuff = z.object({
  type: z.literal("PrefixedBuff"),
  /** The boon, condition, or effect referred to by the fact. */
  status: z.string().optional(),
  /** The description of the status effect. */
  description: z.string().optional(),
  /** The number of stacks applied. */
  apply_count: z.number(),
  /** The duration of the effect in seconds. Note that some facts of this type are just used to display
   * the buff icon with text; in this case, duration is usually 0, or omitted entirely. */
  duration: z.number(),
  /** Buff prefix. */
  prefix: z.object({
    text: z.string(),
    icon: z.string(),
    status: z.string().optional(),
    description: z.string().optional()
  })
});
var Radius = z.object({
  type: z.literal("Radius"),
  /** The radius value. */
  distance: z.number()
});
var Range = z.object({
  type: z.literal("Range"),
  /** The range of the trait/skill. */
  value: z.number()
});
var Recharge = z.object({
  type: z.literal("Recharge"),
  /** The recharge time in seconds. */
  value: z.number()
});
var StunBreak = z.object({
  type: z.literal("StunBreak"),
  /** If present, always true. */
  value: z.literal(true)
});
var Time = z.object({
  type: z.literal("Time"),
  /** The time value in seconds. */
  duration: z.number()
});
var Unblockable = z.object({
  type: z.literal("Unblockable"),
  /** If present, always true. */
  value: z.literal(true)
});
var Facts = z.object({
  /** An arbitrary localized string describing the fact. */
  text: z.string(),
  /** A URL to the icon shown with the fact. Not included with all facts. */
  icon: z.string().optional()
}).and(
  z.discriminatedUnion("type", [
    AttributeAdjust,
    Buff,
    ComboField,
    Finisher,
    Damage,
    Distance,
    Duration,
    Heal,
    HealingAdjust,
    NoData,
    NumberType,
    Percent,
    PrefixedBuff,
    Radius,
    Range,
    Recharge,
    StunBreak,
    Time,
    Unblockable
  ])
);
var TraitedFacts = Facts.and(
  z.object({
    /** Specifies which trait has to be selected in order for this fact to take effect. */
    requires_trait: z.number(),
    /** This specifies the array index of the facts object it will override, if the trait specified in requires_trait is selected.
     * If this field is omitted, then the fact contained within this object is to be appended to the existing facts array. */
    overrides: z.number().optional()
  })
);
var SkillsDTO = z.array(
  z.object({
    /** The skill id. */
    id: z.number(),
    /** The skill name. */
    name: z.string(),
    /** The skill description. */
    description: z.string(),
    /** A URL to an icon of the skill. */
    icon: z.string(),
    /** The chat link. */
    chat_link: z.string(),
    /** The skill type. */
    type: z.enum([
      "Bundle",
      "Elite",
      "Heal",
      "Monster",
      "Pet",
      "Profession",
      "Toolbelt",
      "Transform",
      "Utility",
      "Weapon"
    ]),
    /** Indicates what weapon the skill is on. Can also be None if not applicable. */
    weapon_type: z.string().or(z.literal("None")),
    /** An array of strings indicating which profession(s) can use this skill. */
    professions: z.array(z.string()),
    /** A string indicating where this skill fits into. */
    // optional
    slot: z.union([
      z.custom((val) => typeof val === "string" ? /^Downed_[1-4]$/.test(val) : false),
      z.custom((val) => typeof val === "string" ? /^Profession_[1-5]$/.test(val) : false),
      z.custom((val) => typeof val === "string" ? /^Weapon_[1-5]$/.test(val) : false),
      z.literal("Elite"),
      z.literal("Pet"),
      z.literal("Utility")
    ]),
    /** An array of skill fact objects describing the skill's effect. */
    facts: z.array(Facts).optional(),
    /** An array of skill fact objects that may apply to the skill, dependent on the player's trait choices. */
    traited_facts: z.array(TraitedFacts).optional(),
    /** An array of categories the skill falls under. Mostly used for organizational purposes. */
    categories: z.array(z.string()).optional(),
    /** Used for Elementalist weapon skills, indicates what attunement this skill falls under. */
    attunement: z.enum(["Fire", "Water", "Air", "Earth"]).optional(),
    /** Used for Revenant, Warrior, and Druid skills to indicate their energy cost. */
    cost: z.number().optional(),
    /** Indicates what off-hand must be equipped for this dual-wield skill to appear. */
    dual_wield: z.string().optional(),
    /** Used for skills that "flip over" into a new skill in the same slot to indicate what skill they flip to, such as Engineer toolkits or Herald facets. */
    flip_skill: z.number().optional(),
    /** Indicates the Initiative cost for thief skills. */
    initiative: z.number().optional(),
    /** Indicates the next skill in the chain, if applicable. */
    next_chain: z.number().optional(),
    /** Indicates the previous skill in the chain, if applicable. */
    prev_chain: z.number().optional(),
    /** Used to indicate that the skill will transform the player, replacing their skills with the skills listed in the array. */
    transform_skills: z.array(z.unknown()).optional(),
    /** Used to indicate that the skill will replace the player's skills with the skills listed in the array. */
    bundle_skills: z.array(z.unknown()).optional(),
    /** Used for Engineer utility skills to indicate their associated toolbelt skill. */
    toolbelt_skill: z.number().optional(),
    /** Used to indicate usage limitations, more than one value can be set. */
    flags: z.array(z.enum(["GroundTargeted", "NoUnderwater"]))
  })
);
var WeaponDetails2 = z.object({
  /** The weapon type. */
  type: z.string(),
  /** The damage type. */
  damage_type: z.enum(["Physical", "Fire", "Lightning", "Ice", "Choking"])
});
var GatheringToolDetails = z.object({
  /** The tool type. */
  type: z.enum(["Foraging", "Logging", "Mining"])
});
var RaceGenderChoice = z.enum([
  "AsuraMale",
  "AsuraFemale",
  "CharrMale",
  "CharrFemale",
  "HumanMale",
  "HumanFemale",
  "NornMale",
  "NornFemale",
  "SylvariMale",
  "SylvariFemale"
]);
var ArmorDetails2 = z.object({
  /** The armor type (slot). */
  type: z.string(),
  /** The armor weight. */
  weight_class: z.enum(["Clothing", "Light", "Medium", "Heavy"]),
  /** An object containing information on default slots and skin overrides.
   * If the array item is null, this means dye cannot be applied to that
   * slot, except if otherwise overriden by non-null values in the overrides array. */
  dye_slots: z.object({
    default: z.array(
      z.union([
        z.null(),
        z.object({
          /** The id of the default color. Can be resolved against /v2/colors.*/
          color_id: z.number(),
          /** The type of material. */
          material: z.enum(["cloth", "leather", "metal"])
        })
      ])
    ),
    /** Object of race/gender overrides. */
    overrides: z.record(
      RaceGenderChoice,
      z.object({
        /** The id of the default color. Can be resolved against /v2/colors. */
        color_id: z.number(),
        /** The type of material. */
        material: z.enum(["cloth", "leather", "metal"])
      })
    )
  })
});
var SkinsDTO = z.array(
  z.object({
    /** The skin id. */
    id: z.number(),
    /** The name of the skin. */
    name: z.string(),
    /** The skin type, either Armor, Weapon, Back or Gathering. */
    type: z.string(),
    /**
     * Additional skin flags. Options:
     * ShowInWardrobe – When displayed in the account wardrobe (set for all skins listed in the API).
     * NoCost – When applying the skin is free.
     * HideIfLocked – When the skin is hidden until it is unlocked.
     * OverrideRarity - When the skin overrides item rarity when applied
     */
    flags: z.array(z.enum(["ShowInWardrobe", "NoCost", "HideIfLocked", "OverrideRarity"])),
    /** Race restrictions that apply to the skin, e.g. Human will be a listed restriction, if the skin can only be applied to human characters. */
    restrictions: z.array(z.string()),
    /** The full icon URL. */
    icon: z.string(),
    /** The rarity of the skin */
    rarity: z.string(),
    /** Optional skin description. */
    description: z.string().optional(),
    /** Additional skin details if applicable, depending on the skin type */
    details: z.union([ArmorDetails2, GatheringToolDetails, WeaponDetails2]).optional()
  })
);
var SpecializationsDTO = z.array(
  z.object({
    /** The specialization's ID. */
    id: z.number(),
    /** The name of the specialization. */
    name: z.string(),
    /** The profession that this specialization belongs to. */
    profession: z.string(),
    /** True if this specialization is an Elite specialization, false otherwise. */
    elite: z.boolean(),
    /** A URL to an icon of the specialization. */
    icon: z.string(),
    /** A URL to the background image of the specialization. */
    background: z.string(),
    /** Contains a list of IDs specifying the minor traits in the specialization. */
    minor_traits: z.array(z.number()),
    /** Contains a list of IDs specifying the major traits in the specialization. */
    major_traits: z.array(z.number())
  })
);
var SubtokenDTO = z.object({
  /** Account subtoken. */
  subtoken: z.string()
});
var TitlesDTO = z.array(
  z.object({
    /** The id of the title. */
    id: z.number(),
    /** The name of the title (this is also the title displayed over a character in-game.) */
    name: z.string(),
    /** The id of the achievement that grants this title. Can be resolved against /v2/achievements. */
    achievements: z.array(z.number()).optional(),
    /** The amount of AP required to have said title. */
    ap_required: z.number().optional()
  })
);
var TokenInfoDTO = z.object({
  /** The first half of the API key that was requested. */
  id: z.string(),
  /** The name given to the API key by the account owner.
   * NOTE: The value of this field is not escaped and may contain valid HTML, JavaScript, other code. */
  name: z.string(),
  /**
   * Array of strings describing which permissions the API key has. The array can contain any of:
   * account - Grants access to the /v2/account endpoint (This permission is required for all API keys).
   * builds - Grants access to view each character's equipped specializations and gear.
   * characters - Grants access to the /v2/characters endpoint.
   * guilds - Grants access to guild info under the /v2/guild/:id/ sub-endpoints.
   * inventories - Grants access to inventories in the /v2/characters, /v2/account/bank, and /v2/account/materials endpoints.
   * progression - Grants access to achievements, dungeon unlock status, mastery point assignments, and general PvE progress.
   * pvp - Grants access to the /v2/pvp sub-endpoints. (i.e. /v2/pvp/games, /v2/pvp/stats)
   * tradingpost - Grants access to the /v2/commerce/transactions endpoint.
   * unlocks - Grants access to the /v2/account/skins and /v2/account/dyes endpoints.
   * wallet - Grants access to the /v2/account/wallet endpoint.
   */
  permissions: z.array(
    z.enum([
      "account",
      "builds",
      "characters",
      "guilds",
      "inventories",
      "progression",
      "pvp",
      "tradingpost",
      "unlocks",
      "wallet"
    ])
  ),
  /** The type of the access token given. Either Api key or Subtoken. */
  type: z.string().optional(),
  /** If a subtoken is given, ISO8601 timestamp indicating when the given subtoken expires. */
  expires_at: z.string().optional(),
  /** If a subtoken is given, ISO8601 timestamp indicating when the given subtoken was created. */
  issued_at: z.string().optional(),
  /** If the given subtoken is restricted to a list of URLs, contains an array of strings describing what endpoints are available to this token. */
  urls: z.array(z.string()).optional()
});
var BuffConversion = z.object({
  type: z.literal("BuffConversion"),
  /** The attribute that is used to calculate the attribute gain. */
  source: z.string(),
  /** How much of the source attribute is added to target. */
  percent: z.number(),
  /** The attribute that gets added to. */
  target: z.string()
});
var Facts2 = z.object({
  /** An arbitrary localized string describing the fact.*/
  text: z.string().optional(),
  /** A URL to the icon shown with the fact. Not included with all facts.*/
  icon: z.string().optional()
}).and(
  z.discriminatedUnion("type", [
    AttributeAdjust,
    Buff,
    BuffConversion,
    ComboField,
    Finisher,
    Damage,
    Distance,
    NoData,
    NumberType,
    Percent,
    PrefixedBuff,
    Radius,
    Range,
    Recharge,
    StunBreak,
    Time,
    Unblockable,
    /** Life force cost specifically is missing a type field. */
    z.object({
      type: z.undefined(),
      /** Cost per cast. Life Force ONLY. */
      percent: z.number().optional()
    })
  ])
);
var TraitedFacts2 = Facts2.and(
  z.object({
    /** Specifies which trait has to be selected in order for this fact to take effect. */
    requires_trait: z.number(),
    /** This specifies the array index of the facts object it will override, if the trait specified in requires_trait is selected.
     * If this field is omitted, then the fact contained within this object is to be appended to the existing facts array. */
    overrides: z.number().optional()
  })
);
var Skills2 = z.object({
  /** The ID of the skill. */
  id: z.number(),
  /** The name of the skill. */
  name: z.string(),
  /** The description of the skill. */
  description: z.string(),
  /** The URL for the icon of the skill. */
  icon: z.string(),
  /** A list of tooltip facts associated with the skill. */
  facts: z.array(Facts2).optional(),
  /** A list of additions or changes to tooltip facts where there is interplay between traits. */
  traited_facts: z.array(TraitedFacts2).optional()
});
var TraitsDTO = z.array(
  z.object({
    /** The trait id. */
    id: z.number(),
    /** The trait name. */
    name: z.string(),
    /** The trait's icon URL. */
    icon: z.string(),
    /** The trait description. */
    description: z.string().optional(),
    /** The trait order. */
    order: z.number().optional(),
    /** The id of the specialization this trait belongs to. */
    specialization: z.number(),
    /** The trait's tier (Adept, Master, Grandmaster) as a value from 1-3.
     * Elite specializations also contain a tier 0 minor trait, describing which weapon the elite specialization gains access to. */
    tier: z.number(),
    /** Either Major or Minor depending on the trait's slot.
     * Minor traits are the ones given immediately when choosing a specialization. */
    slot: z.enum(["Major", "Minor"]),
    /** A list of tooltip facts associated with the trait itself. */
    facts: z.array(Facts2).optional(),
    /** A list of additions or changes to tooltip facts where there is interplay between traits. */
    traited_facts: z.array(TraitedFacts2).optional(),
    /** A list of skills which may be triggered by the trait. */
    skills: z.array(Skills2).optional()
  })
);
var WorldsDTO = z.array(
  z.object({
    /** The world id.
     * The first digit of the id indicates the world's region. 1 is North America, 2 is Europe.
     * The second digit of the id currently correlates with the world's assigned language: 1 means French, 2 means German, and 3 means Spanish. */
    id: z.number(),
    /** The world name. */
    name: z.string(),
    /** The world population level. */
    population: z.enum(["Low", "Medium", "High", "VeryHigh", "Full"])
  })
);
var MountsSkinsDTO = z.array(
  z.object({
    /** The id of the mount skin. */
    id: z.number(),
    /** The name of the mount as it appears in-game. */
    name: z.string(),
    /** The full icon URL. */
    icon: z.string(),
    /** The mount type id for the given mount skin. Can be resolved against /v2/mounts/types */
    mount: z.string(),
    /** Each object contains a key-value pair for the dye. */
    dye_slots: z.array(
      z.object({
        /** Color id. Can be resolved against /v2/colors. */
        color_id: z.number(),
        /** Material description. */
        material: z.string()
      })
    )
  })
);
var MountsTypesDTO = z.array(
  z.object({
    /** The id of the mount. */
    id: z.string(),
    /** The name of the mount type as it appears in-game. */
    name: z.string(),
    /** The mount skin a mount has when first obtained. Can be resolved against /v2/mounts/skins. */
    default_skin: z.number(),
    /** An array of mount skin ids. Can be resolved against /v2/mounts/skins. */
    skins: z.array(z.number()),
    /** Each object contains a key-value pair for the skill id and weapon slot. Can be resolved against /v2/skills. */
    skills: z.array(
      z.object({
        /** The skill id. */
        id: z.number(),
        /** The skill slot. */
        slot: z.string()
      })
    )
  })
);
var PvPAmuletsDTO = z.array(
  z.object({
    /** The id of the amulet. */
    id: z.number(),
    /** The name of the amulet. */
    name: z.string(),
    /** The icon uri for the amulet. */
    icon: z.string(),
    /** The list of stats provided by this PvP amulet. */
    attributes: ItemAttributesGeneric
  })
);
var PvPGamesDTO = z.array(
  z.object({
    /** The game's UUID. */
    id: z.string(),
    /** The map the match was played on, cross-referenced from /v2/maps. */
    map_id: z.number(),
    /** A timestamp of when the match started. */
    started: z.string(),
    /** A timestamp of when the match ended. */
    ended: z.string(),
    /** The result of the match. */
    result: z.string(),
    /** The team the player was on during the match. */
    team: z.string(),
    /** The profession the player was playing during the match. */
    profession: z.string(),
    /** The ending scores for each team. */
    scores: z.object({
      /** Red team. */
      red: z.number(),
      /** Blue team. */
      blue: z.number()
    }),
    /** The type of game mode played. */
    rating_type: z.enum(["Ranked", "Unranked", "None"]),
    /** Change in rating as a result of the observed game. Note that number can be negative in the case of a loss. */
    rating_change: z.number().optional(),
    /** Season id. Can be resolved against /v2/pvp/season. */
    season: z.string().optional()
  })
);
var Skins = z.object({
  /** The skin id. */
  id: z.number(),
  /** The name of the skin. */
  name: z.string(),
  /** The icon url for the skin. */
  icon: z.string(),
  /** States if the skin is the default champion skin. */
  default: z.boolean(),
  /** Item ids which unlock the skin. Can be resolved against /v2/items. */
  unlock_items: z.array(z.number())
});
var PvPHeroesDTO = z.array(
  z.object({
    /** The id of the pvp heroes. */
    id: z.string(),
    /** The name of the pvp heroes. */
    name: z.string(),
    /** The flavor type describing the hero. */
    type: z.string(),
    /** An object reflecting the champions stats under offense, defense, or speed. */
    stats: z.object({
      /** Offense. */
      offense: z.number(),
      /** Defense. */
      defense: z.number(),
      /** Speed. */
      speed: z.number()
    }),
    /** The overlay art url for that champion. */
    overlay: z.string(),
    /** The underlay art url for that champion. */
    underlay: z.string(),
    /** The pvp hero skin. */
    skins: z.array(Skins)
  })
);
var PvPRanksDTO = z.array(
  z.object({
    /** The id of the pvp rank. */
    id: z.number(),
    /** The id of the unlocked finisher, can be resolved against /v2/finishers */
    finisher_id: z.number(),
    /** The given name for the PvP rank. */
    name: z.string(),
    /** The icon uri for the Pvp rank. */
    icon: z.string(),
    /** The minimum PvP level required to be at this rank. */
    min_rank: z.number(),
    /** The maximum PvP level required to be at this rank. */
    max_rank: z.number(),
    /** The rank levels. */
    levels: z.array(
      z.object({
        /** The minimum PvP level required to be at this rank. */
        min_rank: z.number(),
        /** The maximum PvP level required to be at this rank. */
        max_rank: z.number(),
        /** The amount of PvP experience needed to go from the given minimum rank to maximum rank. */
        points: z.number()
      })
    )
  })
);
var Divisions = z.object({
  /** The division's name. */
  name: z.string(),
  /** Flags applying to the division. */
  flags: z.array(z.enum(["CanLosePoints", "CanLoseTiers", "Repeatable"])),
  /** Path to the large icon. */
  large_icon: z.string(),
  /** Path to the small icon. */
  small_icon: z.string(),
  /** Path to the pip icon. */
  pip_icon: z.string(),
  /** A list of tiers. */
  tiers: z.array(
    z.object({
      /** The number of pipes contained in each tier. */
      points: z.number()
    })
  )
});
var Ranks = z.object({
  /** The rank's name. */
  name: z.string(),
  /** The rank's description. */
  description: z.string(),
  /** The full icon URL. */
  icon: z.string(),
  /** The full URL for the rank's overlay icon. */
  overlay: z.string(),
  /** The full URL for a small variant of the rank's overlay icon. */
  overlay_small: z.string(),
  /** The tiers of the rank. */
  tiers: z.array(
    z.object({
      /** The minimum PvP rating required for the tier. */
      rating: z.number()
    })
  )
});
var Settings = z.object({
  /** Setting name. NOTE: Broken, always empty. */
  name: z.string(),
  /** Duration setting. NOTE: Broken, always null. Supposed to be a number. */
  duration: z.null(),
  /** Indicates the primary scoring component. */
  scoring: z.string(),
  /** The ladder tiers. */
  tiers: z.array(
    z.object({
      /** Two numbers, a maximum, followed by minimum. */
      range: z.array(z.number()).length(2)
    })
  )
});
var Scorings = z.object({
  /** The id for this scoring method, used as a reference in other endpoints. */
  id: z.string(),
  /** Which variable type the content is saved as. */
  type: z.string(),
  /** Description of the scoring method (if any). */
  description: z.string(),
  /** Should represent the scoring method, such as "wins", "losses", and "skill rating". */
  name: z.string(),
  /** Will describe how the scoring is ordered. */
  ordering: z.string()
});
var Leaderboards = z.object({
  /** The leaderboard ladder. */
  ladder: z.object({
    /** The ladder settings. */
    settings: Settings,
    /** Array used as reference to select player/guild scoring method. */
    scorings: z.array(Scorings)
  }).optional()
});
var PvPSeasonDTO = z.array(
  z.object({
    /** The season's UUID. */
    id: z.string(),
    /** The season's name. */
    name: z.string(),
    /** ISO timestamp for season start. */
    start: z.string(),
    /** ISO timestamp for season end. */
    end: z.string(),
    /** Whether the season is currently active. */
    active: z.boolean(),
    /** A list of divisions. */
    divisions: z.array(Divisions),
    /** Contains details about the season's ranks */
    ranks: z.array(Ranks).optional(),
    /** Contains details on the current leaderboards. */
    leaderboards: Leaderboards
  })
);
var PvPSeasonLeaderboardsDTO = z.array(
  z.object({
    /** Account name. */
    name: z.string(),
    /** Rank for the given player/guild. */
    rank: z.number(),
    /** Guild id. NOTE: Almost never present. */
    id: z.string().optional(),
    /** (only for guild leaderboard) Name of the team. */
    team: z.string().optional(),
    /** (only for guild leaderboard) Internal team id. */
    team_id: z.number().optional(),
    /** Date at which the rank is reached. */
    date: z.string(),
    /** Array of objects containing the id and values for scorings. */
    scores: z.array(
      z.object({
        /** Id for the scoring parameter. Can be compared to the values obtained from /v2/pvp/seasons/:id in the scorings array. */
        id: z.string(),
        /** Value for the given id. */
        value: z.number()
      })
    )
  })
);
var PvPSeasonLeaderboardRegionsDTO = z.array(
  /** The region id. */
  z.string()
);
var Current = z.object({
  /** Total points in the current ladder. */
  total_points: z.number(),
  /** 0-indexed and refers to the data returned by season ID. */
  division: z.number(),
  /** 0-indexed and refers to the data returned by season ID. */
  tier: z.number(),
  /** Current point count. */
  points: z.number(),
  /** The number of times the account has maxed out the "Repeat" division. */
  repeats: z.number(),
  /** The current rating level. For PvP season 5 and after only. */
  rating: z.number().optional(),
  /** The current decay value. For PvP season 5 and after only. */
  decay: z.number().optional()
});
var Best = z.object({
  /** Total points in the current ladder. */
  total_points: z.number(),
  /** 0-indexed and refers to the data returned by season ID. */
  division: z.number(),
  /** 0-indexed and refers to the data returned by season ID. */
  tier: z.number(),
  /** Current point count. */
  points: z.number(),
  /** The number of times the account has maxed out the "Repeat" division. */
  repeats: z.number()
});
var PvPStandingsDTO = z.array(
  z.object({
    /** Current standings. */
    current: Current,
    /** Best standings. */
    best: Best,
    /** The season ID. */
    season_id: z.string()
  })
);
var WinLoss = z.object({
  /** The wins for the category. */
  wins: z.number(),
  /** The losses for the category. */
  losses: z.number(),
  /** The desertions for the category. */
  desertions: z.number(),
  /** The byes for the category. */
  byes: z.number(),
  /** The forfeit for the category. */
  forfeits: z.number()
});
var PvPStatsDTO = z.object({
  /** The player's PvP rank. */
  pvp_rank: z.number(),
  /** The player's PvP rank points. */
  pvp_rank_points: z.number(),
  /** The number of times the player has levelled up since reaching rank 80. If they aren't rank 80 yet, it should be 0. */
  pvp_rank_rollovers: z.number(),
  /** A win/loss object (see below) containing stats from all matches ever played. */
  aggregate: WinLoss,
  /** Contains a sub-object for each profession played in PvP, following the format of the win/loss object. */
  professions: z.record(z.string(), WinLoss),
  /** Contains a sub-object for each type of ladder (i.e. ranked, unranked), each containing a win/loss object. */
  ladders: z.record(z.string(), WinLoss)
});
var StoriesDTO = z.array(
  z.object({
    /** The id of the story. */
    id: z.number(),
    /**
     * The id for the story season.
     * Can be resolved against /v2/stories/seasons.
     */
    season: z.string(),
    /** The name of the story. */
    name: z.string(),
    /** The description of the story. */
    description: z.string(),
    /** The (in-game, not real-world) date of the story. */
    timeline: z.string(),
    /** The minimum level required for a character to begin this story. */
    level: z.number(),
    /** The order in which this story is displayed in the Story Journal. */
    order: z.number(),
    /** An array of chapter objects providing details about the chapters for this story. */
    chapters: z.array(
      z.object({
        /** The name of the chapter. */
        name: z.string()
      })
    ),
    /** When present, provides a list of races that are eligible to participate in this story. */
    races: z.array(z.string()).optional(),
    /** When present, provides a list of additional requirements for a character to participate in this story. */
    flags: z.array(z.string()).optional()
  })
);
var StoriesSeasonsDTO = z.array(
  z.object({
    /** The id of the season. */
    id: z.string(),
    /** The name of the season. */
    name: z.string(),
    /** The order in which this season is displayed in the Story Journal. */
    order: z.number(),
    /** An array of story ids for the stories that belong to this season. */
    stories: z.array(z.number())
  })
);
var WizardsVaultDTO = z.object({
  /** The name of the current season. */
  title: z.string(),
  /** The date that the current season begins. */
  start: z.string(),
  /** The date that the current season ends. */
  end: z.string(),
  /** The wizard's vault listing ids available (use the sub endpoint to view item details). */
  listings: z.array(z.number()),
  /** The wizard's vault objective ids available (use the sub endpoint to view item details). */
  objectives: z.array(z.number())
});
var WizardsVaultListingsDTO = z.array(
  z.object({
    /** The listing id. */
    id: z.number(),
    /** The id of the item */
    item_id: z.number(),
    /** The quantity of the item the user receives */
    item_count: z.number(),
    /** Appears to be the position in the wizards vault UI. */
    type: z.enum(["Featured", "Normal", "Legacy"]),
    /** The quantity of Astral Acclaim to purchase . */
    cost: z.number()
  })
);
var WizardsVaultObjectivesDTO = z.array(
  z.object({
    /** The ID of the objective. */
    id: z.number(),
    /** The title of the objective. */
    title: z.string(),
    /** The reward track containing the objective. */
    track: z.enum(["PvP", "WvW", "PvE"]),
    /** The amount of astral acclaim awarded. */
    acclaim: z.number()
  })
);
var WvWAbilitiesDTO = z.array(
  z.object({
    /** The id of the abilities.*/
    id: z.number(),
    /** The given name for the WvW ability.*/
    name: z.string(),
    /** The given description for the WvW ability.*/
    description: z.string(),
    /** The uri for the ability's icon.*/
    icon: z.string(),
    /** The WvW ranks.*/
    ranks: z.array(
      z.object({
        /** The cost in WvW experience points to purchase the ability.*/
        cost: z.number(),
        /** The effect given to players for obtaining the given ability rank.*/
        effect: z.string()
      })
    )
  })
);
var Scores = z.object({
  /** Score of the red team. */
  red: z.number(),
  /** Score of the blue team. */
  blue: z.number(),
  /** Score of the green team. */
  green: z.number()
});
var WvWMatchesDTO = z.array(
  z.object({
    /** The WvW match id. */
    id: z.string(),
    /** The starting time of the matchup. (ISO-8601 Standard) */
    start_time: z.string(),
    /** The ending time of the matchup. (ISO-8601 Standard) */
    end_time: z.string(),
    /** An object containing the score of the three servers. */
    scores: Scores,
    /** An object containing the IDs of the three primary matchup worlds. */
    worlds: Scores,
    /** n object containing an array of objects with the world IDs of the three servers. */
    all_worlds: z.record(z.string(), z.array(z.number())),
    /** An object containing the total deaths of the three servers. */
    deaths: Scores,
    /** An object containing the total kills of the three servers. */
    kills: Scores,
    /** An object containing the victory points of the three server. */
    victory_points: Scores,
    /** A list of objects containing detailed information about each of the four maps. */
    maps: z.array(
      z.object({
        /** The map id. */
        id: z.number(),
        /** The identifier for the map. Can be either RedHome, GreenHome or BlueHome for the borderlands or Center for Eternal Battlegrounds. */
        type: z.string(),
        /** An object containing the score of the three servers for only the specified map. */
        scores: Scores,
        /** An object containing the total kills of the three servers for only the specified map. */
        kills: Scores,
        /** An object containing the total deaths of the three servers for only the specified map. */
        deaths: Scores,
        /** A list of objective objects for this map. Each object contains the following properties: */
        objectives: z.array(
          z.object({
            /** The objective id. */
            id: z.string(),
            /** The objective type. */
            type: z.enum(["Spawn", "Camp", "Ruins", "Tower", "Keep", "Castle", "Mercenary"]),
            /** The current owner of the objective. */
            owner: z.enum(["Red", "Green", "Blue", "Neutral"]),
            /** The time at which this objective was last captured by a server. (ISO-8601 Standard) */
            last_flipped: z.string(),
            /** The guild id of the guild currently claiming the objective, or null if not claimed. (Not present for unclaimable objectives.) */
            claimed_by: z.union([z.string(), z.null()]).optional(),
            /** The time the objective was claimed by the claimed_by guild (ISO-8601 Standard), or null if not claimed. (Not present for unclaimable objectives.) */
            claimed_at: z.union([z.string(), z.null()]).optional(),
            /** The amount of points per tick the given objective yields. */
            points_tick: z.number(),
            /** The amount of points awarded for capturing the objective. */
            points_capture: z.number(),
            /** An array of ids. Can be resolved against /v2/guild/upgrades, showing which guild upgrades are currently slotted. */
            guild_upgrades: z.array(z.number()).optional(),
            /** The total amount of yak shipments delivered to the objective. Not limited to the shipments within the current tier only. */
            yaks_delivered: z.number().optional()
          })
        ),
        /**
         * A list of all bonuses being granted by this map.
         * If no player team owns a bonus from the map, this list is empty.
         */
        bonuses: z.array(
          z.object({
            /** A shorthand name for the bonus. */
            type: z.literal("Bloodlust"),
            /** The color representing which world group owns the bloodlust. */
            owner: z.string()
          })
        )
      })
    ),
    /** A list of skirmishes. */
    skirmishes: z.array(
      z.object({
        /** The skirmish id . */
        id: z.number(),
        /** Object containing total scores for each team color. */
        scores: Scores,
        /** Contains the map specific scores for the specific skirmish. */
        map_scores: z.array(
          z.object({
            /** Which map is being looked at. */
            type: z.enum(["Center", "RedHome", "BlueHome", "GreenHome"]),
            /** Object containing total scores for each team color on the selected map. */
            scores: Scores
          })
        )
      })
    )
  })
);
var WvWMatchesOverviewDTO = z.object({
  /** The WvW match id. */
  id: z.string(),
  /** The starting time of the matchup. (ISO-8601 Standard) */
  worlds: Scores,
  /** The ending time of the matchup. (ISO-8601 Standard) */
  all_worlds: z.record(z.enum(["red", "blue", "green"]), z.array(z.number())),
  /** An object containing the score of the three servers. */
  start_time: z.string(),
  /** An object containing the IDs of the three primary matchup worlds. */
  end_time: z.string()
});
var WvWMatchesScoresDTO = z.object({
  /** The WvW match id. */
  id: z.string(),
  /** An object containing the score of the three servers. */
  scores: Scores,
  /** A list of objects containing detailed information about each of the four maps. */
  maps: z.array(
    z.object({
      /** The map id. */
      id: z.number(),
      /** The identifier for the map. Can be either RedHome, GreenHome or BlueHome for the borderlands or Center for Eternal Battlegrounds. */
      type: z.string(),
      /** An object containing the score of the three servers for only the specified map. */
      scores: Scores
    })
  ),
  /** A list of skirmishes. */
  skirmishes: z.array(
    z.object({
      /** The skirmish id . */
      id: z.number(),
      /** Object containing total scores for each team color. */
      scores: Scores,
      /** Contains the map specific scores for the specific skirmish. */
      map_scores: z.array(
        z.object({
          /** Which map is being looked at. */
          type: z.enum(["Center", "RedHome", "BlueHome", "GreenHome"]),
          /** Object containing total scores for each team color on the selected map. */
          scores: Scores
        })
      )
    })
  )
});
var WvWMatchesStatsDTO = z.object({
  /** The WvW match id. */
  id: z.string(),
  /** An object containing the total deaths of the three servers. */
  deaths: Scores,
  /** An object containing the total kills of the three servers. */
  kills: Scores,
  /** A list of objects containing detailed information about each of the four maps. */
  maps: z.array(
    z.object({
      /** The map id. */
      id: z.number(),
      /** The identifier for the map. Can be either RedHome, GreenHome or BlueHome for the borderlands or Center for Eternal Battlegrounds. */
      type: z.string(),
      /** An object containing the total deaths of the three servers for only the specified map. */
      deaths: Scores
    })
  )
});
var WvWObjectivesDTO = z.array(
  z.object({
    /** The objective id. */
    id: z.string(),
    /** The name of the objective. */
    name: z.string(),
    /** The type of the objective. */
    type: z.enum(["Camp", "Castle", "Keep", "Mercenary", "Tower", "Ruins", "Resource", "Generic", "Spawn"]),
    /** The map sector the objective can be found in. Refer to /v2/continents. */
    sector_id: z.number(),
    /** The ID of the map that this objective can be found on. */
    map_id: z.number(),
    /** The map that this objective can be found on. */
    map_type: z.enum(["GreenHome", "BlueHome", "RedHome", "Center", "EdgeOfTheMist"]),
    /** An array of three numbers representing the X, Y and Z coordinates of the objectives marker on the map. */
    coord: z.array(z.number()).length(3),
    /** An array of two numbers representing the X and Y coordinates of the sector centroid. */
    label_coord: z.array(z.number()).length(2),
    /** The icon link. */
    marker: z.string(),
    /** The chat code for the observed objective. */
    chat_link: z.string(),
    /** The upgrade id. Can be resolved against /v2/wvw/upgrades. */
    upgrade_id: z.number().optional()
  })
);
var WvWRanksDTO = z.array(
  z.object({
    /** The id of the rank. */
    id: z.number(),
    /** The given title for the WvW rank. */
    title: z.string(),
    /** The minimum WvW level required to be at this rank. */
    min_rank: z.number()
  })
);
var WvWUpgradesDTO = z.array(
  z.object({
    /** The upgrade id. */
    id: z.number(),
    /** The upgrade tiers. */
    tiers: z.array(
      z.object({
        /** The name of the upgrade tier. */
        name: z.string(),
        /** The number of required yaks. */
        yaks_required: z.number(),
        /** The upgrades in each tier. */
        upgrades: z.array(
          z.object({
            /** The name of the upgrade tier. */
            name: z.string(),
            /** The given description for this upgrade. */
            description: z.string(),
            /** The url/image link for the upgrade's icon. */
            icon: z.string()
          })
        )
      })
    )
  })
);

// src/apis/endpoints.ts
var endpoints = {
  account: {
    base: {
      path: "v2/account",
      tokenRequired: true
    },
    achievements: {
      path: "v2/account/achievements",
      tokenRequired: true
    },
    bank: {
      path: "v2/account/bank",
      tokenRequired: true
    },
    buildStorage: {
      path: "v2/account/buildstorage?ids=all",
      tokenRequired: true
    },
    dailyCrafting: {
      path: "v2/account/dailycrafting",
      tokenRequired: true
    },
    dungeons: {
      path: "v2/account/dungeons",
      tokenRequired: true
    },
    dyes: {
      path: "v2/account/dyes",
      tokenRequired: true
    },
    emotes: {
      path: "v2/account/emotes",
      tokenRequired: true
    },
    finishers: {
      path: "v2/account/finishers",
      tokenRequired: true
    },
    gliders: {
      path: "v2/account/gliders",
      tokenRequired: true
    },
    homeCats: {
      path: "v2/account/home/cats",
      tokenRequired: true
    },
    homeNodes: {
      path: "v2/account/home/nodes",
      tokenRequired: true
    },
    homesteadDecorations: {
      path: "v2/account/homestead/decorations",
      tokenRequired: true
    },
    homesteadGlyphs: {
      path: "v2/account/homestead/glyphs",
      tokenRequired: true
    },
    inventory: {
      path: "v2/account/inventory",
      tokenRequired: true
    },
    jadebots: {
      path: "v2/account/jadebots",
      tokenRequired: true
    },
    legendaryArmory: {
      path: "v2/account/legendaryarmory",
      tokenRequired: true
    },
    luck: {
      path: "v2/account/luck",
      tokenRequired: true
    },
    mailCarriers: {
      path: "v2/account/mailcarriers",
      tokenRequired: true
    },
    mapChests: {
      path: "v2/account/mapchests",
      tokenRequired: true
    },
    masteries: {
      path: "v2/account/masteries",
      tokenRequired: true
    },
    masteryPoints: {
      path: "v2/account/mastery/points",
      tokenRequired: true
    },
    materials: {
      path: "v2/account/materials",
      tokenRequired: true
    },
    minis: {
      path: "v2/account/minis",
      tokenRequired: true
    },
    mountsSkins: {
      path: "v2/account/mounts/skins",
      tokenRequired: true
    },
    mountsTypes: {
      path: "v2/account/mounts/types",
      tokenRequired: true
    },
    novelties: {
      path: "v2/account/novelties",
      tokenRequired: true
    },
    outfits: {
      path: "v2/account/outfits",
      tokenRequired: true
    },
    progression: {
      path: "v2/account/progression",
      tokenRequired: true
    },
    pvpHeroes: {
      path: "v2/account/pvp/heroes",
      tokenRequired: true
    },
    raids: {
      path: "v2/account/raids",
      tokenRequired: true
    },
    recipes: {
      path: "v2/account/recipes",
      tokenRequired: true
    },
    skiffs: {
      path: "v2/account/skiffs",
      tokenRequired: true
    },
    skins: {
      path: "v2/account/skins",
      tokenRequired: true
    },
    titles: {
      path: "v2/account/titles",
      tokenRequired: true
    },
    wallet: {
      path: "v2/account/wallet",
      tokenRequired: true
    },
    wizardsVaultDaily: {
      path: "v2/account/wizardsvault/daily",
      tokenRequired: true
    },
    wizardsVaultListings: {
      path: "v2/account/wizardsvault/listings",
      tokenRequired: true
    },
    wizardsVaultSpecial: {
      path: "v2/account/wizardsvault/special",
      tokenRequired: true
    },
    wizardsVaultWeekly: {
      path: "v2/account/wizardsvault/weekly",
      tokenRequired: true
    },
    worldBosses: {
      path: "v2/account/worldbosses",
      tokenRequired: true
    }
  },
  achievements: {
    categoryIds: {
      path: "v2/achievements/categories",
      tokenRequired: false
    },
    categories: {
      path: "v2/achievements/categories?ids=$(ids)",
      tokenRequired: false
    },
    groupsAll: {
      path: "v2/achievements/groups",
      tokenRequired: false
    },
    groupsById: {
      path: "v2/achievements/groups/$(id)",
      tokenRequired: false
    }
  },
  backstory: {
    answersAll: {
      path: "v2/backstory/answers",
      tokenRequired: false
    },
    answersById: {
      path: "v2/backstory/answers?ids=$(ids)",
      tokenRequired: false
    },
    questionsAll: {
      path: "v2/backstory/questions",
      tokenRequired: false
    },
    questionsById: {
      path: "v2/backstory/questions?ids=$(ids)",
      tokenRequired: false
    }
  },
  build: {
    path: "v2/build",
    tokenRequired: false
  },
  characters: {
    base: {
      path: "v2/characters",
      tokenRequired: true
    },
    backstory: {
      path: "v2/characters/$(id)/backstory",
      tokenRequired: true
    },
    buildTabs: {
      path: "v2/characters/$(id)/buildtabs?tabs=$(tabs)",
      tokenRequired: true
    },
    core: {
      path: "v2/characters/$(id)/core",
      tokenRequired: true
    },
    crafting: {
      path: "v2/characters/$(id)/crafting",
      tokenRequired: true
    },
    equipment: {
      path: "v2/characters/$(id)/equipment",
      tokenRequired: true
    },
    equipmentTabsById: {
      path: "v2/characters/$(id)/equipmenttabs?tabs=$(tabs)",
      tokenRequired: true
    },
    equipmentTabActive: {
      path: "v2/characters/$(id)/equipmenttabs/active",
      tokenRequired: true
    },
    heroPoints: {
      path: "v2/characters/$(id)/heropoints",
      tokenRequired: true
    },
    inventory: {
      path: "v2/characters/$(id)/inventory",
      tokenRequired: true
    },
    quests: {
      path: "v2/characters/$(id)/quests",
      tokenRequired: true
    },
    recipes: {
      path: "v2/characters/$(id)/recipes",
      tokenRequired: true
    },
    sab: {
      path: "v2/characters/$(id)/sab",
      tokenRequired: true
    },
    skills: {
      path: "v2/characters/$(id)/skills",
      tokenRequired: true
    },
    specializations: {
      path: "v2/characters/$(id)/specializations",
      tokenRequired: true
    },
    training: {
      path: "v2/characters/$(id)/training",
      tokenRequired: true
    }
  },
  colors: {
    all: {
      path: "v2/colors",
      tokenRequired: false
    },
    byId: {
      path: "v2/colors?ids=$(ids)",
      tokenRequired: false
    }
  },
  commerce: {
    delivery: {
      path: "v2/commerce/delivery",
      tokenRequired: true
    },
    exchange: {
      path: "v2/commerce/exchange/$(type)?quantity=$(quantity)",
      tokenRequired: false
    },
    listings: {
      path: "v2/commerce/listings?ids=$(ids)",
      tokenRequired: false
    },
    prices: {
      path: "v2/commerce/prices?ids=$(ids)",
      tokenRequired: false
    },
    transactions: {
      path: "v2/commerce/transactions/$(status)/$(type)",
      tokenRequired: true
    }
  },
  continents: {
    core: {
      path: "v2/continents",
      tokenRequired: false
    },
    continents: {
      path: "v2/continents?ids=$(continents)",
      tokenRequired: false
    },
    floors: {
      path: "v2/continents/$(continents)/floors?ids=$(floors)",
      tokenRequired: false
    },
    regions: {
      path: "v2/continents/$(continents)/floors/$(floors)/regions?ids=$(regions)",
      tokenRequired: false
    },
    maps: {
      path: "v2/continents/$(continents)/floors/$(floors)/regions/$(regions)/maps?ids=$(maps)",
      tokenRequired: false
    }
  },
  createSubtoken: {
    noUrl: {
      path: "v2/createsubtoken?expire=$(expire)&permissions=$(permissions)",
      tokenRequired: true
    },
    url: {
      path: "v2/createsubtoken?expire=$(expire)&permissions=$(permissions)&urls=$(urls)",
      tokenRequired: true
    }
  },
  currencies: {
    all: {
      path: "v2/currencies",
      tokenRequired: false
    },
    byId: {
      path: "v2/currencies?ids=$(ids)",
      tokenRequired: false
    }
  },
  dailyCrafting: {
    path: "v2/dailycrafting",
    tokenRequired: false
  },
  dungeons: {
    all: {
      path: "v2/dungeons",
      tokenRequired: false
    },
    byId: {
      path: "v2/dungeons?ids=$(ids)",
      tokenRequired: false
    }
  },
  emblem: {
    path: "v2/emblem/$(type)?ids=$(ids)",
    tokenRequired: false
  },
  emotes: {
    all: {
      path: "v2/emotes",
      tokenRequired: false
    },
    byId: {
      path: "v2/emotes?ids=$(ids)",
      tokenRequired: false
    }
  },
  files: {
    all: {
      path: "v2/files",
      tokenRequired: false
    },
    byId: {
      path: "v2/files?ids=$(ids)",
      tokenRequired: false
    }
  },
  finishers: {
    all: {
      path: "v2/finishers",
      tokenRequired: false
    },
    byId: {
      path: "v2/finishers?ids=$(ids)",
      tokenRequired: false
    }
  },
  gliders: {
    all: {
      path: "v2/gliders",
      tokenRequired: false
    },
    byId: {
      path: "v2/gliders?ids=$(ids)",
      tokenRequired: false
    },
    paginated: {
      path: "v2/gliders?ids=$(ids)&page=$(page)&page_size=$(page_size)",
      tokenRequired: false
    }
  },
  guild: {
    core: {
      path: "v2/guild/$(id)",
      tokenRequired: false
    },
    log: {
      path: "v2/guild/$(id)/log?since=$(since)",
      tokenRequired: true
    },
    members: {
      path: "v2/guild/$(id)/members",
      tokenRequired: true
    },
    ranks: {
      path: "v2/guild/$(id)/ranks",
      tokenRequired: true
    },
    stash: {
      path: "v2/guild/$(id)/stash",
      tokenRequired: true
    },
    storage: {
      path: "v2/guild/$(id)/storage",
      tokenRequired: true
    },
    teams: {
      path: "v2/guild/$(id)/teams",
      tokenRequired: true
    },
    treasury: {
      path: "v2/guild/$(id)/treasury",
      tokenRequired: true
    },
    upgrades: {
      path: "v2/guild/$(id)/upgrades",
      tokenRequired: true
    },
    upgradesInfo: {
      path: "v2/guild/upgrades?ids=$(ids)",
      tokenRequired: false
    },
    permissionsAll: {
      path: "v2/guild/permissions",
      tokenRequired: false
    },
    permissionsById: {
      path: "v2/guild/permissions?ids=$(ids)",
      tokenRequired: false
    },
    search: {
      path: "v2/guild/search?name=$(name)",
      tokenRequired: false
    }
  },
  home: {
    cats: {
      path: "v2/home/cats?ids=$(ids)",
      tokenRequired: false
    },
    nodes: {
      path: "v2/home/nodes?ids=$(ids)",
      tokenRequired: false
    }
  },
  homestead: {
    decorationsById: {
      path: "v2/homestead/decorations?ids=$(ids)",
      tokenRequired: false
    },
    decorationsAll: {
      path: "v2/homestead/decorations",
      tokenRequired: false
    },
    decorationsCategoriesById: {
      path: "v2/homestead/decorations/categories?ids=$(ids)",
      tokenRequired: false
    },
    decorationsCategoriesAll: {
      path: "v2/homestead/decorations/categories",
      tokenRequired: false
    },
    glyphsById: {
      path: "v2/homestead/glyphs?ids=$(ids)",
      tokenRequired: false
    },
    glyphsAll: {
      path: "v2/homestead/glyphs",
      tokenRequired: false
    }
  },
  items: {
    all: {
      path: "v2/items",
      tokenRequired: false
    },
    byId: {
      path: "v2/items?ids=$(ids)",
      tokenRequired: false
    }
  },
  itemstats: {
    all: {
      path: "v2/itemstats",
      tokenRequired: false
    },
    byId: {
      path: "v2/itemstats?ids=$(ids)",
      tokenRequired: false
    }
  },
  jadebots: {
    all: {
      path: "v2/jadebots",
      tokenRequired: false
    },
    byId: {
      path: "v2/jadebots?ids=$(ids)",
      tokenRequired: false
    }
  },
  legendaryArmory: {
    all: {
      path: "v2/legendaryarmory",
      tokenRequired: false
    },
    byId: {
      path: "v2/legendaryarmory?ids=$(ids)",
      tokenRequired: false
    }
  },
  legends: {
    all: {
      path: "v2/legends",
      tokenRequired: false
    },
    byId: {
      path: "v2/legends?ids=$(ids)",
      tokenRequired: false
    }
  },
  mailCarriers: {
    all: {
      path: "v2/mailcarriers",
      tokenRequired: false
    },
    byId: {
      path: "v2/mailcarriers?ids=$(ids)",
      tokenRequired: false
    }
  },
  mapChests: {
    path: "v2/mapchests",
    tokenRequired: false
  },
  maps: {
    all: {
      path: "v2/maps",
      tokenRequired: false
    },
    byId: {
      path: "v2/maps?ids=$(ids)",
      tokenRequired: false
    }
  },
  masteries: {
    all: {
      path: "v2/masteries",
      tokenRequired: false
    },
    byId: {
      path: "v2/masteries?ids=$(ids)",
      tokenRequired: false
    }
  },
  materials: {
    all: {
      path: "v2/materials",
      tokenRequired: false
    },
    byId: {
      path: "v2/materials?ids=$(ids)",
      tokenRequired: false
    }
  },
  minis: {
    all: {
      path: "v2/minis",
      tokenRequired: false
    },
    byId: {
      path: "v2/minis?ids=$(ids)",
      tokenRequired: false
    }
  },
  mountsSkins: {
    all: {
      path: "v2/mounts/skins",
      tokenRequired: false
    },
    byId: {
      path: "v2/mounts/skins?ids=$(ids)",
      tokenRequired: false
    }
  },
  mountsTypes: {
    all: {
      path: "v2/mounts/types",
      tokenRequired: false
    },
    byId: {
      path: "v2/mounts/types?ids=$(ids)",
      tokenRequired: false
    }
  },
  novelties: {
    all: {
      path: "v2/novelties",
      tokenRequired: false
    },
    byId: {
      path: "v2/novelties?ids=$(ids)",
      tokenRequired: false
    }
  },
  outfits: {
    all: {
      path: "v2/outfits",
      tokenRequired: false
    },
    byId: {
      path: "v2/outfits?ids=$(ids)",
      tokenRequired: false
    }
  },
  pets: {
    all: {
      path: "v2/pets",
      tokenRequired: false
    },
    byId: {
      path: "v2/pets?ids=$(ids)",
      tokenRequired: false
    }
  },
  professions: {
    all: {
      path: "v2/professions",
      tokenRequired: false
    },
    byId: {
      path: "v2/professions?ids=$(ids)",
      tokenRequired: false
    }
  },
  pvp: {
    amuletsAll: {
      path: "v2/pvp/amulets",
      tokenRequired: false
    },
    amuletsById: {
      path: "v2/pvp/amulets?ids=$(ids)",
      tokenRequired: false
    },
    gamesAll: {
      path: "v2/pvp/games",
      tokenRequired: true
    },
    gamesById: {
      path: "v2/pvp/games?ids=$(ids)",
      tokenRequired: true
    },
    heroesAll: {
      path: "v2/pvp/heroes",
      tokenRequired: false
    },
    heroesById: {
      path: "v2/pvp/heroes?ids=$(ids)",
      tokenRequired: false
    },
    ranksAll: {
      path: "v2/pvp/ranks",
      tokenRequired: false
    },
    ranksById: {
      path: "v2/pvp/ranks?ids=$(ids)",
      tokenRequired: false
    },
    seasonsAll: {
      path: "v2/pvp/seasons",
      tokenRequired: false
    },
    seasonsById: {
      path: "v2/pvp/seasons?ids=$(ids)",
      tokenRequired: false
    },
    leaderboards: {
      path: "v2/pvp/seasons/$(id)/leaderboards/$(type)/$(region)",
      tokenRequired: false
    },
    leaderboardsNoType: {
      path: "v2/pvp/seasons/$(id)/leaderboards",
      tokenRequired: false
    },
    standings: {
      path: "v2/pvp/standings",
      tokenRequired: true
    },
    stats: {
      path: "v2/pvp/stats",
      tokenRequired: true
    }
  },
  quaggans: {
    all: {
      path: "v2/quaggans",
      tokenRequired: false
    },
    byId: {
      path: "v2/quaggans?ids=$(ids)",
      tokenRequired: false
    }
  },
  quests: {
    all: {
      path: "v2/quests",
      tokenRequired: false
    },
    byId: {
      path: "v2/quests?ids=$(ids)",
      tokenRequired: false
    }
  },
  races: {
    all: {
      path: "v2/races",
      tokenRequired: false
    },
    byId: {
      path: "v2/races?ids=$(ids)",
      tokenRequired: false
    }
  },
  raids: {
    all: {
      path: "v2/raids",
      tokenRequired: false
    },
    byId: {
      path: "v2/raids?ids=$(ids)",
      tokenRequired: false
    }
  },
  recipes: {
    byId: {
      /**
       * TODO: The hardcoded schema could use some work
       */
      path: "v2/recipes?ids=$(ids)&v=2022-03-09T02:00:00.000Z",
      tokenRequired: false
    },
    all: {
      path: "v2/recipes",
      tokenRequired: false
    },
    search: {
      path: "v2/recipes/search?$(type)=$(ids)",
      tokenRequired: false
    }
  },
  skiffs: {
    all: {
      path: "v2/skiffs",
      tokenRequired: false
    },
    byId: {
      path: "v2/skiffs?ids=$(ids)",
      tokenRequired: false
    }
  },
  skills: {
    path: "v2/skills?ids=$(ids)",
    tokenRequired: false
  },
  skins: {
    all: {
      path: "v2/skins",
      tokenRequired: false
    },
    byId: {
      path: "v2/skins?ids=$(ids)",
      tokenRequired: false
    }
  },
  specializations: {
    all: {
      path: "v2/specializations",
      tokenRequired: false
    },
    byId: {
      path: "v2/specializations?ids=$(ids)",
      tokenRequired: false
    }
  },
  stories: {
    all: {
      path: "v2/stories",
      tokenRequired: false
    },
    byId: {
      path: "v2/stories?ids=$(ids)",
      tokenRequired: false
    }
  },
  seasons: {
    all: {
      path: "v2/stories/seasons",
      tokenRequired: false
    },
    byId: {
      path: "v2/stories/seasons?ids=$(ids)",
      tokenRequired: false
    }
  },
  titles: {
    all: {
      path: "v2/titles",
      tokenRequired: false
    },
    byId: {
      path: "v2/titles?ids=$(ids)",
      tokenRequired: false
    }
  },
  tokenInfo: {
    path: "v2/tokeninfo",
    tokenRequired: true
  },
  traits: {
    all: {
      path: "v2/traits",
      tokenRequired: false
    },
    byId: {
      path: "v2/traits?ids=$(ids)",
      tokenRequired: false
    }
  },
  wizardsVault: {
    root: {
      path: "v2/wizardsvault",
      tokenRequired: false
    },
    listingsAll: {
      path: "v2/wizardsvault/listings",
      tokenRequired: false
    },
    listingsById: {
      path: "v2/wizardsvault/listings?ids=$(ids)",
      tokenRequired: false
    },
    objectivesAll: {
      path: "v2/wizardsvault/objectives",
      tokenRequired: false
    },
    objectivesById: {
      path: "v2/wizardsvault/objectives?ids=$(ids)",
      tokenRequired: false
    }
  },
  worldBosses: {
    path: "v2/worldbosses",
    tokenRequired: false
  },
  worlds: {
    all: {
      path: "v2/worlds",
      tokenRequired: false
    },
    byId: {
      path: "v2/worlds?ids=$(ids)",
      tokenRequired: false
    }
  },
  wvw: {
    abilities: {
      path: "v2/wvw/abilities",
      tokenRequired: false
    },
    abilitiesById: {
      path: "v2/wvw/abilities?ids=$(ids)",
      tokenRequired: false
    },
    matches: {
      path: "v2/wvw/matches",
      tokenRequired: false
    },
    matchesById: {
      path: "v2/wvw/matches?ids=$(ids)",
      tokenRequired: false
    },
    matchesByWorld: {
      path: "v2/wvw/matches/$(type)?world=$(world)",
      tokenRequired: false
    },
    objectives: {
      path: "v2/wvw/objectives",
      tokenRequired: false
    },
    objectivesById: {
      path: "v2/wvw/objectives?ids=$(ids)",
      tokenRequired: false
    },
    ranks: {
      path: "v2/wvw/ranks",
      tokenRequired: false
    },
    ranksById: {
      path: "v2/wvw/ranks?ids=$(ids)",
      tokenRequired: false
    },
    upgradesById: {
      path: "v2/wvw/upgrades?ids=$(ids)",
      tokenRequired: false
    },
    upgradesAll: {
      path: "v2/wvw/upgrades",
      tokenRequired: false
    }
  }
};

// src/apis/account/account.ts
var AccountApi = class extends ApiBase {
  /**
   * Returns information about player accounts.
   */
  async get() {
    return await this.buildRequest(endpoints.account.base, {}, AccountDTO);
  }
  /**
   * Returns an account's progress towards all their achievements.
   */
  async getAchievements() {
    return await this.buildRequest(
      endpoints.account.achievements,
      {},
      AccountAchievementsDTO
    );
  }
  /**
   * Returns the items stored in a player's vault (not including material storage).
   * If null, the slot is empty.
   */
  async getBank() {
    return await this.buildRequest(endpoints.account.bank, {}, AccountBankDTO);
  }
  /**
   * Returns the templates stored in a player's build storage.
   */
  async getBuildStorage() {
    return await this.buildRequest(
      endpoints.account.buildStorage,
      {},
      AccountBuildStorageDTO
    );
  }
  /**
   * Returns information about time-gated recipes that have been crafted by the account since daily-reset.
   */
  async getDailyCrafts() {
    return await this.buildRequest(
      endpoints.account.dailyCrafting,
      {},
      AccountDailyCraftingDTO
    );
  }
  /**
   * Returns the dungeons completed since daily dungeon reset.
   */
  async getDungeons() {
    return await this.buildRequest(endpoints.account.dungeons, {}, AccountDungeonsDTO);
  }
  /**
   * Returns the unlocked dyes of the account.
   */
  async getDyes() {
    return await this.buildRequest(endpoints.account.dyes, {}, AccountDyesDTO);
  }
  /**
   * Returns the player's unlocked emotes.
   */
  async getEmotes() {
    return await this.buildRequest(endpoints.account.emotes, {}, AccountEmotesDTO);
  }
  /**
   * Returns information about finishers that are unlocked for an account.
   */
  async getFinishers() {
    return await this.buildRequest(
      endpoints.account.finishers,
      {},
      AccountFinishersDTO
    );
  }
  /**
   * Returns information about gliders that are unlocked for an account.
   */
  async getGliders() {
    return await this.buildRequest(endpoints.account.gliders, {}, AccountGlidersDTO);
  }
  /**
   * Returns information about unlocked home instance nodes.
   */
  async getHomeNodes() {
    return await this.buildRequest(
      endpoints.account.homeNodes,
      {},
      AccountHomeNodesDTO
    );
  }
  /**
   * Returns information about unlocked home instance cats.
   */
  async getHomeCats() {
    return await this.buildRequest(endpoints.account.homeCats, {}, AccountHomeCatsDTO);
  }
  /**
   * Returns information about unlocked homestead decorations.
   */
  async getHomesteadDecorations() {
    return await this.buildRequest(
      endpoints.account.homesteadDecorations,
      {},
      AccountHomesteadDecorationsDTO
    );
  }
  /**
   * Returns information about glyphs stored in homestead collection boxes.
   */
  async getHomesteadGlyphs() {
    return await this.buildRequest(
      endpoints.account.homesteadGlyphs,
      {},
      AccountHomesteadGlyphsDTO
    );
  }
  /**
   * Returns the shared inventory slots in an account.
   * If null, the slot is empty
   */
  async getInventory() {
    return await this.buildRequest(
      endpoints.account.inventory,
      {},
      AccountInventoryDTO
    );
  }
  /**
   * Returns the unlocked Jade Bot skins of the account.
   */
  async getJadebots() {
    return await this.buildRequest(endpoints.account.jadebots, {}, AccountJadebotsDTO);
  }
  /**
   * Returns information about the Legendary Armory items that are unlocked for an account.
   */
  async getLegendaryArmory() {
    return await this.buildRequest(
      endpoints.account.legendaryArmory,
      {},
      AccountLegendaryArmoryDTO
    );
  }
  /**
   * Returns the total amount of luck consumed on an account.
   */
  async getLuck() {
    return await this.buildRequest(endpoints.account.luck, {}, AccountLuckDTO);
  }
  /**
   * Returns information about mail carriers that are unlocked for an account.
   */
  async getMailCarriers() {
    return await this.buildRequest(
      endpoints.account.mailCarriers,
      {},
      AccountMailCarriersDTO
    );
  }
  /**
   * Returns information about Hero's Choice Chests acquired by the account since daily-reset.
   */
  async getMapChests() {
    return await this.buildRequest(
      endpoints.account.mapChests,
      {},
      AccountMapChestsDTO
    );
  }
  /**
   * Returns information about masteries that are unlocked for an account.
   * A tallied up total of the account's mastery points can be found at /v2/account/mastery/points.
   */
  async getMasteries() {
    return await this.buildRequest(
      endpoints.account.masteries,
      {},
      AccountMasteriesDTO
    );
  }
  /**
   * Returns information about the total amount of mastery points that are unlocked for an account.
   * A detailed mastery track completion break down is available at /v2/account/masteries.
   */
  async getMasteryPoints() {
    return await this.buildRequest(
      endpoints.account.masteryPoints,
      {},
      AccountMasteryPointsDTO
    );
  }
  /**
   * Returns the materials stored in a player's vault.
   */
  async getMaterials() {
    return await this.buildRequest(
      endpoints.account.materials,
      {},
      AccountMaterialsDTO
    );
  }
  /**
   * Returns the unlocked miniatures of the account.
   */
  async getMinis() {
    return await this.buildRequest(endpoints.account.minis, {}, AccountMinisDTO);
  }
  /**
   * Returns the unlocked mount skins of the account.
   */
  async getMountSkins() {
    return await this.buildRequest(
      endpoints.account.mountsSkins,
      {},
      AccountMountSkinsDTO
    );
  }
  /**
   * Returns the unlocked mounts of the account.
   */
  async getMountTypes() {
    return await this.buildRequest(
      endpoints.account.mountsTypes,
      {},
      AccountMountTypesDTO
    );
  }
  /**
   * Returns information about novelties that are unlocked for an account.
   */
  async getNovelties() {
    return await this.buildRequest(
      endpoints.account.novelties,
      {},
      AccountNoveltiesDTO
    );
  }
  /**
   * Returns information about outfits that are unlocked for an account.
   */
  async getOutfits() {
    return await this.buildRequest(endpoints.account.outfits, {}, AccountOutfitsDTO);
  }
  /**
   * Returns account-wide progression for Fractals's Account Augmentation and Luck.
   */
  async getProgression() {
    return await this.buildRequest(
      endpoints.account.progression,
      {},
      AccountProgressionDTO
    );
  }
  /**
   * Returns information about pvp heroes that are unlocked for an account.
   */
  async getPvpHeroes() {
    return await this.buildRequest(
      endpoints.account.pvpHeroes,
      {},
      AccountPvpHeroesDTO
    );
  }
  /**
   * Returns the completed raid encounters since weekly raid reset.
   */
  async getRaids() {
    return await this.buildRequest(endpoints.account.raids, {}, AccountRaidsDTO);
  }
  /**
   * Returns information about recipes that are unlocked for an account.
   */
  async getRecipes() {
    return await this.buildRequest(endpoints.account.recipes, {}, AccountRecipesDTO);
  }
  /**
   * Returns the unlocked Skiff skins of the account.
   */
  async getSkiffs() {
    return await this.buildRequest(endpoints.account.skiffs, {}, AccountSkiffsDTO);
  }
  /**
   * Returns the unlocked skins of the account.
   */
  async getSkins() {
    return await this.buildRequest(endpoints.account.skins, {}, AccountSkinsDTO);
  }
  /**
   * Returns information about titles that are unlocked for an account.
   */
  async getTitles() {
    return await this.buildRequest(endpoints.account.titles, {}, AccountTitlesDTO);
  }
  /**
   * Returns the currencies of the account
   */
  async getWallet() {
    return await this.buildRequest(endpoints.account.wallet, {}, AccountWalletDTO);
  }
  /**
   * Returns the current set of daily Wizard's Vault achievements for the account.
   */
  async getWizardsVaultDaily() {
    return await this.buildRequest(
      endpoints.account.wizardsVaultDaily,
      {},
      AccountWizardsVaultDailyDTO
    );
  }
  /**
   * Returns the current set of Wizard's Vault rewards, along with details about which have already been purchased by the account, and in what quantity.
   */
  async getWizardsVaultListings() {
    return await this.buildRequest(
      endpoints.account.wizardsVaultListings,
      {},
      AccountWizardsVaultListingsDTO
    );
  }
  /**
   * Returns the current set of special Wizard's Vault achievements for the account.
   */
  async getWizardsVaultSpecial() {
    return await this.buildRequest(
      endpoints.account.wizardsVaultSpecial,
      {},
      AccountWizardsVaultSpecialDTO
    );
  }
  /**
   * Returns the current set of weekly Wizard's Vault achievements for the account.
   */
  async getWizardsVaultWeekly() {
    return await this.buildRequest(
      endpoints.account.wizardsVaultWeekly,
      {},
      AccountWizardsVaultWeeklyDTO
    );
  }
  /**
   * Returns information about which world bosses have been killed by the account since daily-reset.
   */
  async getWorldBosses() {
    return await this.buildRequest(
      endpoints.account.worldBosses,
      {},
      AccountWorldBossesDTO
    );
  }
};

// src/apis/achievements/achievements.ts
var AchievementsApi = class extends ApiBase {
  async getCategories(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.achievements.categories,
        { ids },
        AchievementCategoriesDTO
      );
    return await this.buildRequest(endpoints.achievements.categoryIds, {}, numberArrayType);
  }
  async getGroups(id) {
    if (id)
      return await this.buildRequest(
        endpoints.achievements.groupsById,
        { id },
        AchievementGroupsDTO
      );
    return await this.buildRequest(endpoints.achievements.groupsAll, {}, stringArrayType);
  }
};

// src/apis/characters/characters.ts
var CharactersApi = class extends ApiBase {
  /**
   * Returns information about characters attached to a specific account.
   */
  async get() {
    return await this.buildRequest(endpoints.characters.base, {}, CharactersDTO);
  }
  /**
   * Returns information about the backstory of a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getBackstory(id) {
    return await this.buildRequest(
      endpoints.characters.backstory,
      { id },
      CharacterBackstoryDTO
    );
  }
  /**
   * Returns information about the build template tabs of a character.
   *
   * @param id - Character name
   * @param tabs - Optional tab index. If the index is invalid, all tabs will be returned
   */
  async getBuildTabs(id, tabs = "all") {
    if (Array.isArray(tabs)) {
      for (const tab of tabs) {
        if (tab < 1 || tab > 9) {
          logger.warn("Build tab ids must be between 1 and 9. Returning all tabs");
          tabs = "all";
        }
      }
    }
    return await this.buildRequest(
      endpoints.characters.buildTabs,
      {
        id,
        tabs
      },
      CharacterBuildTabsDTO
    );
  }
  /**
   * Returns core information about a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getCore(id) {
    return await this.buildRequest(endpoints.characters.core, { id }, CharacterCoreDTO);
  }
  /**
   * Returns information about the crafting disciplines available to a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getCrafting(id) {
    return await this.buildRequest(
      endpoints.characters.crafting,
      { id },
      CharacterCraftingDTO
    );
  }
  /**
   * Returns equipment of a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getEquipment(id) {
    return await this.buildRequest(
      endpoints.characters.equipment,
      { id },
      CharacterEquipmentDTO
    );
  }
  /**
   * Returns information about an accounts equipment template tabs.
   *
   * @param id - Character name
   * @param tabs - Optional equipment tab number.
   */
  async getEquipmentTabs(id, tabs = "all") {
    if (Array.isArray(tabs)) {
      for (const tab of tabs) {
        if (tab < 1 || tab > 9) {
          logger.warn("Equipment tab ids must be between 1 and 9. Returning all tabs.");
          tabs = "all";
        }
      }
    }
    return await this.buildRequest(
      endpoints.characters.equipmentTabsById,
      {
        id,
        tabs
      },
      CharacterEquipmentTabsDTO
    );
  }
  /**
   * Returns the active equipment tab of a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getActiveEquipmentTab(id) {
    return await this.buildRequest(
      endpoints.characters.equipmentTabActive,
      { id },
      CharacterEquipmentTabDTO
    );
  }
  /**
   * Returns information about the hero points obtained by a character attached to a specific account.
   * NOTE: This api does not currently return a lot of hero point values.
   * Check the list here for details https://wiki.guildwars2.com/wiki/API:2/characters/:id/heropoints#Notes
   *
   * @param id - Character name
   */
  async getHeroPoints(id) {
    return await this.buildRequest(
      endpoints.characters.heroPoints,
      { id },
      CharacterHeroPointsDTO
    );
  }
  /**
   * Returns inventory of a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getInventory(id) {
    return await this.buildRequest(
      endpoints.characters.inventory,
      { id },
      CharacterInventoryDTO
    );
  }
  /**
   * Returns information about the quests selected that by a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getQuests(id) {
    return await this.buildRequest(
      endpoints.characters.quests,
      { id },
      CharacterQuestsDTO
    );
  }
  /**
   * Returns information about recipes that the given character can use.
   *
   * @param id - Character name
   */
  async getRecipes(id) {
    return await this.buildRequest(
      endpoints.characters.recipes,
      { id },
      CharacterRecipesDTO
    );
  }
  /**
   * Returns information about Super Adventure Box on a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getSAB(id) {
    return await this.buildRequest(
      endpoints.characters.sab,
      { id },
      CharacterSuperAdventureBoxDTO
    );
  }
  /**
   * Returns information about the skills equipped on a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getSkills(id) {
    return await this.buildRequest(
      endpoints.characters.skills,
      { id },
      CharacterSkillsDTO
    );
  }
  /**
   * Returns information about the specializations equipped on a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getSpecializations(id) {
    return await this.buildRequest(
      endpoints.characters.specializations,
      {
        id
      },
      CharacterSpecializationsDTO
    );
  }
  /**
   * Returns information about the training of a character attached to a specific account.
   *
   * @param id - Character name
   */
  async getTraining(id) {
    return await this.buildRequest(
      endpoints.characters.training,
      { id },
      CharacterTrainingDTO
    );
  }
};

// src/apis/commerce/commerce.ts
var CommerceApi = class extends ApiBase {
  /**
   * Provides access to the current items and coins available for pickup on this account.
   */
  async getDeliveries() {
    return await this.buildRequest(
      endpoints.commerce.delivery,
      {},
      CommerceDeliveryDTO
    );
  }
  /**
   * Returns the current coins to gems exchange rate, or vice versa.
   *
   * @param type - Gems to coins, or vice versa
   * @param quantity - Quantity of coins to be exchanged (in copper coins)
   */
  async getExchange(type, quantity) {
    return await this.buildRequest(
      endpoints.commerce.exchange,
      { type, quantity },
      CommerceExchangeDTO
    );
  }
  /**
   * Returns current buy and sell listings from the trading post.
   * TODO: Functionality to return a complete list of every listing is currently unsupported
   *
   * @param ids - Listing ids
   */
  async getListings(ids) {
    return await this.buildRequest(
      endpoints.commerce.listings,
      { ids },
      CommerceListingsDTO
    );
  }
  /**
   * Returns current aggregated buy and sell listing information from the trading post.
   * TODO: Functionality to return a complete list of every listing is currently unsupported
   *
   * @param ids - Item ids
   */
  async getPrices(ids) {
    return await this.buildRequest(endpoints.commerce.prices, { ids }, CommercePricesDTO);
  }
  /**
   * Provides access to the current and historical transactions of a player.
   * Results are cached for 5 minutes.
   *
   * @param status - Current or historical transactions
   * @param type - Buy or sell transactions
   */
  async getTransactions(status, type) {
    return await this.buildRequest(
      endpoints.commerce.transactions,
      { status, type },
      CommerceTransactionDTO
    );
  }
};

// src/apis/emblem/emblem.ts
var EmblemApi = class extends ApiBase {
  /**
   * Returns image resources that are needed to render the guild emblems.
   *
   * @param type - Background or foreground
   * @param ids - List of emblem ids, or "all"
   */
  async get(type, ids = "all") {
    return await this.buildRequest(
      endpoints.emblem,
      {
        type,
        ids
      },
      EmblemDTO
    );
  }
};

// src/apis/guild/guild.ts
var GuildApi = class extends ApiBase {
  /**
   * Returns core details about a given guild.
   * The end point will include more or less fields depend on whether an API Key of a Leader or
   * Member of the Guild with the guilds scope is included in the request.
   *
   * @param id - The guild id
   */
  async get(id) {
    return await this.buildRequest(endpoints.guild.core, { id }, GuildDTO);
  }
  /**
   * Returns information about certain events in a guild's log.
   * The endpoint requires the scope guilds, and will only work if the API key is from the guild leader's account.
   *
   * @param id - Unique guild id
   * @param since - Starting point for the log, by log id
   */
  async getLog(id, since = 0) {
    return await this.buildRequest(endpoints.guild.log, { id, since }, GuildLogDTO);
  }
  /**
   * Returns information about the members of a specified guild.
   * The endpoint requires the scope guilds, and will only work if the API key is from the guild leader's account.
   *
   * @param id - Unique guild id
   */
  async getMembers(id) {
    return await this.buildRequest(endpoints.guild.members, { id }, GuildMembersDTO);
  }
  /**
   * Returns information about the ranks of a specified guild.
   * The endpoint requires the scope guilds, and will only work if the API key is from the guild leader's account.
   *
   * @param id - Unique guild id
   */
  async getRanks(id) {
    return await this.buildRequest(endpoints.guild.ranks, { id }, GuildRanksDTO);
  }
  /**
   * Returns information about the items in a guild's vault.
   * The endpoint requires the scope guilds, and will only work if the API key is from the guild leader's account.
   *
   * @param id - Unique guild id
   */
  async getStash(id) {
    return await this.buildRequest(endpoints.guild.stash, { id }, GuildStashDTO);
  }
  /**
   * Returns information about the items in a guild's storage.
   * The endpoint requires the scope guilds, and will only work if the API key is from the guild leader's account.
   *
   * @param id - Unique guild id
   */
  async getStorage(id) {
    return await this.buildRequest(endpoints.guild.storage, { id }, GuildStorageDTO);
  }
  /**
   * Returns information about the teams in a guild.
   * The endpoint requires the scope guilds, and will only work if the API key is from the guild leader's account.
   *
   * @param id - Unique guild id
   */
  async getTeams(id) {
    return await this.buildRequest(endpoints.guild.teams, { id }, GuildTeamsDTO);
  }
  /**
   * Returns information about the items in a guild's treasury.
   * The endpoint requires the scope guilds, and will only work if the API key is from the guild leader's account.
   *
   * @param id - Unique guild id
   */
  async getTreasury(id) {
    return await this.buildRequest(endpoints.guild.treasury, { id }, GuildTreasuryDTO);
  }
  /**
   * Returns information about the guild's upgrades.
   * The endpoint requires the scope guilds, and will only work if the API key is from the guild leader's account.
   *
   * @param id - Unique guild id
   */
  async getUpgrades(id) {
    return await this.buildRequest(endpoints.guild.upgrades, { id }, GuildUpgradesDTO);
  }
  /**
   * Returns information about all guild permissions.
   *
   * @param ids - Permission ids
   */
  async getPermissions(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.guild.permissionsById,
        { ids },
        GuildPermissionsDTO
      );
    return await this.buildRequest(endpoints.guild.permissionsAll, {}, stringArrayType);
  }
  /**
   * Returns information on guild ids to be used for other API queries.
   *
   * @param name - Guild name
   */
  async find(name) {
    return await this.buildRequest(endpoints.guild.search, { name }, GuildSearchDTO);
  }
  /**
   * Returns information about all available Guild Hall upgrades, including scribe decorations.
   *
   * @param ids - Guild upgrade ids
   */
  async upgradeInfo(ids) {
    return await this.buildRequest(
      endpoints.guild.upgradesInfo,
      { ids },
      GuildUpgradesInfoDTO
    );
  }
};

// src/apis/home/home.ts
var HomeApi = class extends ApiBase {
  /**
   * Returns information about cats.
   * Identical to /v2/cats
   *
   * @param ids - List of cat ids, or "all"
   */
  async getCats(ids = "all") {
    return await this.buildRequest(endpoints.home.cats, { ids }, HomeCatsDTO);
  }
  /**
   * Returns a list of all currently available home instance nodes.
   * Can be resolved against /v2/account/home/nodes to identify an account's unlocked nodes.
   *
   * @param ids - List of node ids, or "all"
   */
  async getNodes(ids = "all") {
    return await this.buildRequest(
      endpoints.home.nodes,
      {
        ids
      },
      HomeNodesDTO
    );
  }
};

// src/apis/homestead/homestead.ts
var HomesteadApi = class extends ApiBase {
  async getDecorations(ids) {
    if (ids) {
      return await this.buildRequest(
        endpoints.homestead.decorationsById,
        { ids },
        HomesteadDecorationsDTO
      );
    }
    return await this.buildRequest(endpoints.homestead.decorationsAll, {}, numberArrayType);
  }
  async getCategories(ids) {
    if (ids) {
      return await this.buildRequest(
        endpoints.homestead.decorationsCategoriesById,
        { ids },
        HomesteadDecorationsCategoriesDTO
      );
    }
    return await this.buildRequest(
      endpoints.homestead.decorationsCategoriesAll,
      {},
      numberArrayType
    );
  }
  async getGlyphs(ids) {
    if (ids) {
      return await this.buildRequest(
        endpoints.homestead.glyphsById,
        { ids },
        HomesteadGlyphsDTO
      );
    }
    return await this.buildRequest(endpoints.homestead.glyphsAll, {}, stringArrayType);
  }
};

// src/apis/misc/backstory.ts
var BackstoryApi = class extends ApiBase {
  async getAnswers(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.backstory.answersById,
        { ids },
        BackstoryAnswersDTO
      );
    return await this.buildRequest(endpoints.backstory.answersAll, {}, stringArrayType);
  }
  async getQuestions(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.backstory.questionsById,
        { ids },
        BackstoryQuestionsDTO
      );
    return await this.buildRequest(endpoints.backstory.questionsAll, {}, numberArrayType);
  }
};

// src/apis/misc/build.ts
var BuildApi = class extends ApiBase {
  /**
   * Returns the current build id of the game.
   * NOTE: This endpoint is broken, and after a certain timestamp, seems to be returning the exact same value.
   */
  async get() {
    return await this.buildRequest(endpoints.build, {}, BuildDTO);
  }
};

// src/apis/misc/colors.ts
var ColorsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.colors.byId, { ids }, ColorsDTO);
    return await this.buildRequest(endpoints.colors.all, {}, numberArrayType);
  }
};

// src/apis/misc/continents.ts
var ContinentsApi = class extends ApiBase {
  async getContinents(continents, floors, regions, maps) {
    if (typeof continents === "number") {
      if (typeof floors === "number") {
        if (typeof regions === "number") {
          if (maps) {
            return await this.buildRequest(
              endpoints.continents.maps,
              {
                continents,
                floors,
                regions,
                maps
              },
              ContinentsMapsDTO
            );
          }
        } else if (Array.isArray(regions) || regions === "all") {
          return await this.buildRequest(
            endpoints.continents.regions,
            {
              continents,
              floors,
              regions
            },
            ContinentsRegionsDTO
          );
        }
      } else if (Array.isArray(floors) || floors === "all") {
        return await this.buildRequest(
          endpoints.continents.floors,
          {
            continents,
            floors
          },
          ContinentsFloorsDTO
        );
      }
    } else if (Array.isArray(continents) || continents === "all") {
      return await this.buildRequest(
        endpoints.continents.continents,
        {
          continents
        },
        ContinentsDTO
      );
    }
    return await this.buildRequest(endpoints.continents.core, {}, numberArrayType);
  }
};

// src/apis/misc/currencies.ts
var CurrenciesApi = class extends ApiBase {
  async get(ids) {
    if (ids)
      return await this.buildRequest(endpoints.currencies.byId, { ids }, CurrenciesDTO);
    return await this.buildRequest(endpoints.currencies.all, {}, numberArrayType);
  }
};

// src/apis/misc/dailyCrafting.ts
var DailyCraftingApi = class extends ApiBase {
  /**
   * Returns information about time-gated recipes that can be crafted in-game.
   */
  async get() {
    return await this.buildRequest(endpoints.dailyCrafting, {}, stringArrayType);
  }
};

// src/apis/misc/dungeons.ts
var DungeonsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.dungeons.byId, { ids }, DungeonsDTO);
    return await this.buildRequest(endpoints.dungeons.all, {}, stringArrayType);
  }
};

// src/apis/misc/emotes.ts
var EmotesApi = class extends ApiBase {
  async get(ids) {
    if (ids && Array.isArray(ids)) {
      ids = ids.map((id) => {
        if (["shiverplus", "stretch"].includes(id.toLocaleLowerCase()))
          return id[0]?.toLocaleUpperCase() + id.substring(1);
        return id.toLocaleLowerCase();
      });
      return await this.buildRequest(endpoints.emotes.byId, { ids }, EmotesDTO);
    }
    return await this.buildRequest(endpoints.emotes.all, {}, stringArrayType);
  }
};

// src/apis/misc/files.ts
var FilesApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.files.byId, { ids }, FilesDTO);
    return await this.buildRequest(endpoints.files.all, {}, stringArrayType);
  }
};

// src/apis/misc/finishers.ts
var FinishersApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.finishers.byId, { ids }, FinishersDTO);
    return await this.buildRequest(endpoints.finishers.all, {}, numberArrayType);
  }
};

// src/apis/misc/gliders.ts
var GlidersApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.gliders.byId, { ids }, GlidersDTO);
    return await this.buildRequest(endpoints.gliders.all, {}, numberArrayType);
  }
};

// src/apis/misc/items.ts
var ItemsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.items.byId, { ids }, ItemsDTO);
    return await this.buildRequest(endpoints.items.all, {}, numberArrayType);
  }
};

// src/apis/misc/itemstats.ts
var ItemStatsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.itemstats.byId, { ids }, ItemStatsDTO);
    return await this.buildRequest(endpoints.itemstats.all, {}, numberArrayType);
  }
};

// src/apis/misc/jadebots.ts
var JadebotsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.jadebots.byId, { ids }, JadebotsDTO);
    return await this.buildRequest(endpoints.jadebots.all, {}, numberArrayType);
  }
};

// src/apis/misc/legendaryarmory.ts
var LegendaryArmoryApi = class extends ApiBase {
  async get(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.legendaryArmory.byId,
        { ids },
        LegendaryArmoryDTO
      );
    return await this.buildRequest(endpoints.legendaryArmory.all, {}, numberArrayType);
  }
};

// src/apis/misc/legends.ts
var LegendsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.legends.byId, { ids }, LegendsDTO);
    return await this.buildRequest(endpoints.legends.all, {}, stringArrayType);
  }
};

// src/apis/misc/mailCarriers.ts
var MailCarriersApi = class extends ApiBase {
  async get(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.mailCarriers.byId,
        { ids },
        MailCarriersDTO
      );
    return await this.buildRequest(endpoints.mailCarriers.all, {}, numberArrayType);
  }
};

// src/apis/misc/mapChests.ts
var MapChestsApi = class extends ApiBase {
  /**
   * Returns information about Hero's Choice Chests that can be acquired once a day in-game.
   * NOTE: This endpoint is known to have missing data.
   */
  async get() {
    return await this.buildRequest(endpoints.mapChests, {}, MapChestsDTO);
  }
};

// src/apis/misc/maps.ts
var MapsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.maps.byId, { ids }, MapsDTO);
    return await this.buildRequest(endpoints.maps.all, {}, numberArrayType);
  }
};

// src/apis/misc/masteries.ts
var MasteriesApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.masteries.byId, { ids }, MasteriesDTO);
    return await this.buildRequest(endpoints.masteries.all, {}, numberArrayType);
  }
};

// src/apis/misc/materials.ts
var MaterialsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.materials.byId, { ids }, MaterialsDTO);
    return await this.buildRequest(endpoints.materials.all, {}, numberArrayType);
  }
};

// src/apis/misc/minis.ts
var MinisApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.minis.byId, { ids }, MinisDTO);
    return await this.buildRequest(endpoints.minis.all, {}, numberArrayType);
  }
};

// src/apis/misc/mounts.ts
var MountsApi = class extends ApiBase {
  async getSkins(ids) {
    if (ids)
      return await this.buildRequest(endpoints.mountsSkins.byId, { ids }, MountsSkinsDTO);
    return await this.buildRequest(endpoints.mountsSkins.all, {}, numberArrayType);
  }
  async getTypes(ids) {
    if (ids)
      return await this.buildRequest(endpoints.mountsTypes.byId, { ids }, MountsTypesDTO);
    return await this.buildRequest(endpoints.mountsTypes.all, {}, stringArrayType);
  }
};

// src/apis/misc/novelties.ts
var NoveltiesApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.novelties.byId, { ids }, NoveltiesDTO);
    return await this.buildRequest(endpoints.novelties.all, {}, numberArrayType);
  }
};

// src/apis/misc/outfits.ts
var OutfitsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.outfits.byId, { ids }, OutfitsDTO);
    return await this.buildRequest(endpoints.outfits.all, {}, numberArrayType);
  }
};

// src/apis/misc/pets.ts
var PetsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.pets.byId, { ids }, PetsDTO);
    return await this.buildRequest(endpoints.pets.all, {}, numberArrayType);
  }
};

// src/apis/misc/professions.ts
var ProfessionsApi = class extends ApiBase {
  async get(ids) {
    if (ids)
      return await this.buildRequest(endpoints.professions.byId, { ids }, ProfessionsDTO);
    return await this.buildRequest(endpoints.professions.all, {}, stringArrayType);
  }
};

// src/apis/misc/quaggans.ts
var QuaggansApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.quaggans.byId, { ids }, QuaggansDTO);
    return await this.buildRequest(endpoints.quaggans.all, {}, stringArrayType);
  }
};

// src/apis/misc/quests.ts
var QuestsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.quests.byId, { ids }, QuestsDTO);
    return await this.buildRequest(endpoints.quests.all, {}, numberArrayType);
  }
};

// src/apis/misc/races.ts
var RacesApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.races.byId, { ids }, RacesDTO);
    return await this.buildRequest(endpoints.races.all, {}, stringArrayType);
  }
};

// src/apis/misc/raids.ts
var RaidsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.raids.byId, { ids }, RaidsDTO);
    return await this.buildRequest(endpoints.raids.all, {}, stringArrayType);
  }
};

// src/apis/misc/recipes.ts
var RecipesApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.recipes.byId, { ids }, RecipesDTO);
    return await this.buildRequest(endpoints.recipes.all, {}, numberArrayType);
  }
  /**
   * Allows searching for recipe.
   *
   * @param type - Either "input" or "output"
   * @param ids - List of item ids
   */
  async search(type, ids) {
    return await this.buildRequest(
      endpoints.recipes.search,
      { type, ids },
      numberArrayType
    );
  }
};

// src/apis/misc/skiffs.ts
var SkiffsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.skiffs.byId, { ids }, SkiffsDTO);
    return await this.buildRequest(endpoints.skiffs.all, {}, numberArrayType);
  }
};

// src/apis/misc/skills.ts
var SkillsApi = class extends ApiBase {
  /**
   * Returns information about skills usable by players in the game.
   *
   * @param ids - List of skill ids
   */
  async get(ids) {
    return await this.buildRequest(endpoints.skills, { ids }, SkillsDTO);
  }
};

// src/apis/misc/skins.ts
var SkinsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.skins.byId, { ids }, SkinsDTO);
    return await this.buildRequest(endpoints.skins.all, {}, numberArrayType);
  }
};

// src/apis/misc/specializations.ts
var SpecializationsApi = class extends ApiBase {
  async get(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.specializations.byId,
        { ids },
        SpecializationsDTO
      );
    return await this.buildRequest(endpoints.specializations.all, {}, numberArrayType);
  }
};
var storiesCore = z.array(z.number());
var seasonsCore = z.array(z.string());
var StoriesApi = class extends ApiBase {
  async getStories(ids) {
    if (ids) return await this.buildRequest(endpoints.stories.byId, { ids }, StoriesDTO);
    return await this.buildRequest(endpoints.stories.all, {}, storiesCore);
  }
  async getSeasons(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.seasons.byId,
        { ids },
        StoriesSeasonsDTO
      );
    return await this.buildRequest(endpoints.seasons.all, {}, seasonsCore);
  }
};

// src/apis/misc/subtoken.ts
var SubtokenApi = class extends ApiBase {
  /**
   * Creates a subtoken, or an Api key with limited permissions.
   *
   * @param expire - Expiration date. Either valid date format, or ISO-8601
   * @param permissions - Api token permissions
   * @param urls - Specific /v2/ api urls to allow access to
   */
  async get(expire, permissions, urls) {
    try {
      expire = new Date(expire).toISOString();
    } catch (e) {
      if (e instanceof RangeError) {
        logger.error("Date must be of valid, or of ISO-8601 format.");
        throw new RangeError();
      }
    }
    if (urls) {
      return await this.buildRequest(
        endpoints.createSubtoken.url,
        {
          expire,
          permissions,
          urls
        },
        SubtokenDTO
      );
    }
    return await this.buildRequest(
      endpoints.createSubtoken.noUrl,
      {
        expire,
        permissions
      },
      SubtokenDTO
    );
  }
};

// src/apis/misc/titles.ts
var TitlesApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.titles.byId, { ids }, TitlesDTO);
    return await this.buildRequest(endpoints.titles.all, {}, numberArrayType);
  }
};

// src/apis/misc/tokeninfo.ts
var TokenInfoApi = class extends ApiBase {
  /**
   * Returns information about the supplied API key.
   */
  async get() {
    return await this.buildRequest(endpoints.tokenInfo, {}, TokenInfoDTO);
  }
};

// src/apis/misc/traits.ts
var TraitsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.traits.byId, { ids }, TraitsDTO);
    return await this.buildRequest(endpoints.traits.all, {}, numberArrayType);
  }
};

// src/apis/misc/worldbosses.ts
var WorldBossesApi = class extends ApiBase {
  /**
   * Returns information about scheduled World bosses in Core Tyria that reward boss chests that can be be opened once a day in-game.
   */
  async get() {
    return await this.buildRequest(endpoints.worldBosses, {}, stringArrayType);
  }
};

// src/apis/misc/worlds.ts
var WorldsApi = class extends ApiBase {
  async get(ids) {
    if (ids) return await this.buildRequest(endpoints.worlds.byId, { ids }, WorldsDTO);
    return await this.buildRequest(endpoints.worlds.all, {}, numberArrayType);
  }
};

// src/apis/pvp/pvp.ts
var PvPApi = class extends ApiBase {
  async getAmulets(ids) {
    if (ids)
      return await this.buildRequest(endpoints.pvp.amuletsById, { ids }, PvPAmuletsDTO);
    return await this.buildRequest(endpoints.pvp.amuletsAll, {}, numberArrayType);
  }
  async getGames(ids) {
    if (ids) return await this.buildRequest(endpoints.pvp.gamesById, { ids }, PvPGamesDTO);
    return await this.buildRequest(endpoints.pvp.gamesAll, {}, stringArrayType);
  }
  async getHeroes(ids) {
    if (ids) return await this.buildRequest(endpoints.pvp.heroesById, { ids }, PvPHeroesDTO);
    return await this.buildRequest(endpoints.pvp.heroesAll, {}, stringArrayType);
  }
  async getRanks(ids) {
    if (ids) return await this.buildRequest(endpoints.pvp.ranksById, { ids }, PvPRanksDTO);
    return await this.buildRequest(endpoints.pvp.ranksAll, {}, numberArrayType);
  }
  async getSeasons(ids) {
    if (ids) return await this.buildRequest(endpoints.pvp.seasonsById, { ids }, PvPSeasonDTO);
    return await this.buildRequest(endpoints.pvp.seasonsAll, {}, stringArrayType);
  }
  async getLeaderboards(id, region, type) {
    if (type && region)
      return await this.buildRequest(
        endpoints.pvp.leaderboards,
        { id, type, region },
        PvPSeasonLeaderboardsDTO
      );
    return await this.buildRequest(
      endpoints.pvp.leaderboardsNoType,
      { id },
      PvPSeasonLeaderboardRegionsDTO
    );
  }
  /**
   * Returns information about player pips.
   */
  async getStandings() {
    return await this.buildRequest(endpoints.pvp.standings, {}, PvPStandingsDTO);
  }
  /**
   * Resource returns information about wins and losses in the account's PvP matches.
   */
  async getStats() {
    return await this.buildRequest(endpoints.pvp.stats, {}, PvPStatsDTO);
  }
};

// src/apis/wizardsvault/wizardsvault.ts
var WizardsVaultApi = class extends ApiBase {
  /**
   * Returns information about the current Wizard's Vault season.
   */
  async get() {
    return await this.buildRequest(endpoints.wizardsVault.root, {}, WizardsVaultDTO);
  }
  async getListings(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.wizardsVault.listingsById,
        { ids },
        WizardsVaultListingsDTO
      );
    return await this.buildRequest(endpoints.wizardsVault.listingsAll, {}, numberArrayType);
  }
  async getObjectives(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.wizardsVault.objectivesById,
        { ids },
        WizardsVaultObjectivesDTO
      );
    return await this.buildRequest(
      endpoints.wizardsVault.objectivesAll,
      {},
      numberArrayType
    );
  }
};

// src/apis/wvw/wvw.ts
var WorldVsWorldApi = class extends ApiBase {
  async getAbilities(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.wvw.abilitiesById,
        { ids },
        WvWAbilitiesDTO
      );
    return await this.buildRequest(endpoints.wvw.abilities, {}, numberArrayType);
  }
  async getMatches(ids) {
    if (ids) {
      return await this.buildRequest(endpoints.wvw.matchesById, { ids }, WvWMatchesDTO);
    }
    return await this.buildRequest(endpoints.wvw.matches, {}, stringArrayType);
  }
  /**
   * Returns further details about the specified match, including the total score, kills and deaths, and further details for each map.
   * The same information as {@link WorldVsWorldApi#getMatches}, however more limited.
   *
   * @param type - Overview, Scores, or Stats for the matches
   * @param world - World id
   */
  async getMatchesByWorld(type, world) {
    if (type === "overview") {
      return await this.buildRequest(
        endpoints.wvw.matchesByWorld,
        {
          type,
          world
        },
        WvWMatchesOverviewDTO
      );
    }
    if (type === "scores") {
      return await this.buildRequest(
        endpoints.wvw.matchesByWorld,
        {
          type,
          world
        },
        WvWMatchesScoresDTO
      );
    }
    return await this.buildRequest(
      endpoints.wvw.matchesByWorld,
      {
        type,
        world
      },
      WvWMatchesStatsDTO
    );
  }
  async getObjectives(ids) {
    if (ids)
      return await this.buildRequest(
        endpoints.wvw.objectivesById,
        { ids },
        WvWObjectivesDTO
      );
    return await this.buildRequest(endpoints.wvw.objectives, {}, stringArrayType);
  }
  async getRanks(ids) {
    if (ids) return await this.buildRequest(endpoints.wvw.ranksById, { ids }, WvWRanksDTO);
    return await this.buildRequest(endpoints.wvw.ranks, {}, numberArrayType);
  }
  async getUpgrades(ids) {
    if (ids)
      return await this.buildRequest(endpoints.wvw.upgradesById, { ids }, WvWUpgradesDTO);
    return await this.buildRequest(endpoints.wvw.upgradesAll, {}, numberArrayType);
  }
};

// src/api.ts
var GW2Api = class extends ApiBase {
  /** /v2/account Api */
  account = new AccountApi(this.getParams());
  /** /v2/achievements Api */
  achievements = new AchievementsApi(this.getParams());
  /** /v2/backstory Api */
  backstory = new BackstoryApi(this.getParams());
  /** /v2/build Api */
  build = new BuildApi(this.getParams());
  /** /v2/characters Api */
  characters = new CharactersApi(this.getParams());
  /** /v2/colors Api */
  colors = new ColorsApi(this.getParams());
  /** /v2/commerce Api */
  commerce = new CommerceApi(this.getParams());
  /** /v2/continents Api */
  continents = new ContinentsApi(this.getParams());
  /** /v2/currencies Api */
  currencies = new CurrenciesApi(this.getParams());
  /** /v2/dailycrafting Api */
  dailyCrafting = new DailyCraftingApi(this.getParams());
  /** /v2/dungeons Api */
  dungeons = new DungeonsApi(this.getParams());
  /** /v2/emblem Api */
  emblem = new EmblemApi(this.getParams());
  /** /v2/emotes Api */
  emotes = new EmotesApi(this.getParams());
  /** /v2/files Api */
  files = new FilesApi(this.getParams());
  /** /v2/finishers Api */
  finishers = new FinishersApi(this.getParams());
  /** /v2/gliders Api */
  gliders = new GlidersApi(this.getParams());
  /** /v2/guild Api */
  guild = new GuildApi(this.getParams());
  /** /v2/home Api */
  home = new HomeApi(this.getParams());
  /** /v2/homestead Api */
  homestead = new HomesteadApi(this.getParams());
  /** /v2/items Api */
  items = new ItemsApi(this.getParams());
  /** /v2/itemstats Api */
  itemstats = new ItemStatsApi(this.getParams());
  /** /v2/jadebots Api */
  jadebots = new JadebotsApi(this.getParams());
  /** /v2/legendaryarmory Api */
  legendaryArmory = new LegendaryArmoryApi(this.getParams());
  /** /v2/legends Api */
  legends = new LegendsApi(this.getParams());
  /** /v2/mailcarriers Api */
  mailCarriers = new MailCarriersApi(this.getParams());
  /** /v2/mapchests Api */
  mapChests = new MapChestsApi(this.getParams());
  /** /v2/maps Api */
  maps = new MapsApi(this.getParams());
  /** /v2/masteries Api */
  masteries = new MasteriesApi(this.getParams());
  /** /v2/materials Api */
  materials = new MaterialsApi(this.getParams());
  /** /v2/minis Api */
  minis = new MinisApi(this.getParams());
  /** /v2/mounts Api */
  mounts = new MountsApi(this.getParams());
  /** /v2/novelties Api */
  novelties = new NoveltiesApi(this.getParams());
  /** /v2/outfits Api */
  outfits = new OutfitsApi(this.getParams());
  /** /v2/pets Api */
  pets = new PetsApi(this.getParams());
  /** /v2/professions Api */
  professions = new ProfessionsApi(this.getParams());
  /** /v2/pvp Api */
  pvp = new PvPApi(this.getParams());
  /** /v2/quaggans Api */
  quaggans = new QuaggansApi(this.getParams());
  /** /v2/quests Api */
  quests = new QuestsApi(this.getParams());
  /** /v2/races Api */
  races = new RacesApi(this.getParams());
  /** /v2/raids Api */
  raids = new RaidsApi(this.getParams());
  /** /v2/recipes Api */
  recipes = new RecipesApi(this.getParams());
  /** /v2/skiffs Api */
  skiffs = new SkiffsApi(this.getParams());
  /** /v2/skills Api */
  skills = new SkillsApi(this.getParams());
  /** /v2/skins Api */
  skins = new SkinsApi(this.getParams());
  /** /v2/specializations Api */
  specializations = new SpecializationsApi(this.getParams());
  /** /v2/stories Api */
  stories = new StoriesApi(this.getParams());
  /** /v2/subtoken Api */
  subtoken = new SubtokenApi(this.getParams());
  /** /v2/titles Api */
  titles = new TitlesApi(this.getParams());
  /** /v2/tokeninfo Api */
  tokenInfo = new TokenInfoApi(this.getParams());
  /** /v2/traits Api */
  traits = new TraitsApi(this.getParams());
  /** /v2/wizardsvault Api */
  wizardsVault = new WizardsVaultApi(this.getParams());
  /** /v2/worldbosses Api */
  worldBosses = new WorldBossesApi(this.getParams());
  /** /v2/worlds Api */
  worlds = new WorldsApi(this.getParams());
  /** /v2/wvw Api */
  wvw = new WorldVsWorldApi(this.getParams());
};

export { ApiLanguage, GW2Api, LogLevel, setLogLevel, setPathLogging };
